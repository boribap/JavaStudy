## OOP Modeling
### Modeling 
#### 모델링을 하는 이유 
* 서로의 해석을 공유해 합의를 이루거나 해석의 타당성을 검토할 수 있음
* 현재 시스템 또는 앞으로 개발할 시스템의 원하는 모습을 가시화한다. 
* 시스템의 구조와 행위를 명세할 수 있으며 시스템을 구축하는 틀을 제공하기 위함이다. 

### UML
UML은 대표적인 모델링 언어. 요구 분석, 시스템 설계, 시스템 구현 등의 시스템 개발 과정에서 개발자 사이의 의사 소통이 원활하게 이루어지도록 표준화한 통합 모델링 언어.     

### Class Diagram
* 클래스란?     
동일한 속성과 행위를 수행하는 객체의 집합.      
객체를 생성하는 설계도로 생각할 수도 있음. 

* UML에서 클래스를 표현    

| 클래스 이름  |
|---|
|  속성 (클래스의 특징 나타냄) |
|  연산 (클래스가 수행하는 책임) |     

위와 같이 나타내고 속성과 연산부분은 생략 가능하다.     

* 속성과 연산의 표기     
    
|   | 표기  |
|---|---|
|속성 | [+/-/#/~]이름:타입[다중성정보][=초기값] |
|연산   |  [+/-/#/~]이름:(인자1:타입1, ... , 인자n:타입n):반환타입 |



* 접근 제어자    
외부에 속성과 연산을 어느 정도 공개하느냐에 따라 다른 접근 제어자 사용.    
 
| 접근 제어자  | 표시  |  설명 |
|---|---|---|
| public  | +  | 어떤 클래스의 객체어서든 접근 가능  |
| private | - | 이 클래스에서 생성된 객체들만 접근 가능  |
| protected  | #  | 이 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능  |
| package  | ~  | 동일 패키지에 있는 클래스의 객체들만 접근 가능  |    

> 문제 1. 다음 클래스를 코드로 작성해보기    
![문제1](https://user-images.githubusercontent.com/28684368/38104421-0917440a-33c4-11e8-8b5c-e52213557fd5.png)

* 관계    

    * 연관 관계  (양방향 / 단방향 / 재귀적)  
    
        - 클래스들이 개념상 연결되었음을 나타냄. 실선/화살표를 이용. 양방향 일 경우에는 실선을 사용한다. 한쪽으로만 방향성이 있는 단방향 연관관계라면 화살표 사용.       
        - 연관관계에서의 역할 이름은 연관된 클래스들의 객체들이 서로를 참조할 수 있는 속성의 이름으로 활용할 수 있음.    
        - 연관관계를 나타내는 선에 숫자가 없다면 일대일 관계를 의미함. 그렇지 않은 경우 '다중성 표시 방법'을 따른다.     
        
        |다중성 표기 | 의미 |
        |---|---|
        |1|엄밀하게 1|
        |*|0 또는 그 이상|
        |0..*|0 또는 그 이상|
        |1..*|1 이상|
        |0..1|0 또는 1|
        |2..5|2 또는 3 또는 4 또는 5|
        |1,2,6|1 또는 2 또는 6|
        
        - 왼쪽의 클래스는 오른쪽 클래스를 오른쪽 숫자만큼 가질 수 있다 라고 해석하면 된다.     
        - 다중성을 어떻게 하느냐에 따라 일반적으로 방향성이 달라진다. (다대다 연관관계는 양방향 연관관계.)
        - 연관 클래스 : 연관 관계에 추가할 속성이나 행위가 있을 때 사용. 연관 관계를 나타내려고 연결한 선 중앙에서 연관 클래스까지 점선을 이용해 연결. 하지만 연관 클래스는 일반 클래스로 변환되어 구현된다. (점선이 아닌 실선으로 연결)    
        - 재귀적인 연관 관계가 있을 수 있음. 
             ![재귀적1](https://user-images.githubusercontent.com/28684368/38123641-297fbbc0-3417-11e8-9b1d-639951c9051a.png)
             위와 같이 생각해보면 B는 2가지 역할 모두를 수행. 이런 경우가 빈번히 있으므로 역할을 클래스로 만들지 않는 것이 좋음.     
     
             ![제귀적2](https://user-images.githubusercontent.com/28684368/38123645-2c52d03a-3417-11e8-9e88-9513f0f64a4c.png)
             역할을 클래스로 만들지 않고 한개의 클래스 안에서 역할을 가지게 하면 위와 같이 재귀적인 연관 관계를 가지게 되는 것.     
             하지만 C가 A를 관리하는 상황이 오게 되면 '관계의 루프'에 빠지게 된다. 이런 상황을 배제하기 위해 {} 안에 제약을 설정할 수 있다.     
             (여기서는 {계층}을 사용하였고, 객체 사이에 상하관계가 존재하고 사이클이 존재하지 않는다는 의미이다.)   
        
    * 일반화 관계
        
        - 상속 관계. 자식이라 불리는 클래스는 부모라 불리는 클래스로부터 속성과 연산을 물려받을 수 있다. 속이 빈 화살표를 사용. 
        - 예시) 가전제품(부모클래스) / 세탁기, TV (자식클래스)  
        
            모두 turnOn, turnOff 기능 있음. 하지만 동작이 다르므로 부모클래스에서는 연산을 정의하지않고 자식클래스에서 정의해야함. 부모클래스에서는 구현되지 않은 빈껍데기만 있게됨. 추상 메서드라고 한다.     
            추상 메서드를 한개 이상 가지고 있는 클래스를 추상 클래스라고 한다.     
            추상 클래스와 추상 메서드는 이탤릭체, '<<','>>'를 사용해 표시 
            
        - 일반화 관계는 두 클래스 사이에 "is kind of 관계"가 성립할 때 사용. 
            
    * 집합 관계  (집약 / 합성)    
        
        - 집약 관계 : 한 객체가 다른 객체를 포함하는 것. '전체', '부분'과의 관계이며, '전체'를가리키는 클래스 방향에 빈 마름모로 표시.  
            전체 객체의 라이프 타임과 부분 객체의 라이프 타임은 **독립적**. (전체 객체 사라져도 부분 객체 살아있음)     
            부분 객체를 여러 전체 객체가 공유가능.  
            
            ![집약관계1](https://user-images.githubusercontent.com/28684368/38125813-3231566a-3427-11e8-9268-9b4858898c1a.png)   
            컴퓨터가 전체 객체인것을 알수 있다. 
            
        - 합성 관계 : 부분 객체가 전체 객체에 속하는 관계. 전체를 가리키는 클래스 방햐에 채워진 마름모로 표시.     
            부분 객체의 라이프 타임은 전체 객체의 라이프 타임에 **의존적**. (전체 객체 사라지면 부분 객체도 사라짐)    
            부분 객체를 여러 전체 객체가 공유 불가능    
            
    * 의존 관계
         
        - 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때를 나타냄. 차이점은 두 클래스의 관계가 한 메서드를 실행하는 동안과 같이, 매우 짧은 시간만 유지된다는 점. 점선 화살표를 사용해 표시.     
        - 클래스의 속성에서 참조할 때 / 연산의 인자로 사용될 때 / 메서드 내부의 지역 객체로 참조될 때 
        - 자동차와 소유주 (연관관계-오랜시간 함께) 자동차와 주유기 (의존관계-짧은 시간 함께)
         
    * 인터페이스와 실체화 관계     
        - 인터페이스와 이 책임들을 실제로 실현할 클래스들 사이의 관계를 나타냄. 속이 빈 삼각형과 점선을 사용해 표기.     
        - 실체와 관계는 "can do this 관계"가 성립할 때 사용. 
        - 인터페이스 : 공통되는 능력 관점에서 그룹화 할 수 있는 메커니즘. 책임(객체가 해야 하는 일)들의 집합.    
        ![인터페이스1](https://user-images.githubusercontent.com/28684368/38126511-0c8a261c-342c-11e8-8e32-c221e1c013ce.png)  
        