#### 자바 기본서를 읽으면서 내가 몰랐던 부분 혹은 기록하고 싶은 부분만을 적어둠. 전부를 적어두는 것이 아님. 

# 자바 기본 공부 1
## 자바 프로그램의 실행 구조와 자바 가상머신 
__다른 프로그램들__ 은 운영체제가 직접 실행시키는 구조이지만 __자바 프로그램__ 은 자바 가상머신에 의해서 실행되는 구조이다.    
그 이유는 자바 프로그램을 운영체제에 상관없이 실행 시키기 위함이다. 운영체제에 따른 차이점을 자바 가상머신이 대신해주는 것이다. 그래서 가상머신은 운영체제에 따라 다르다.     

## 자바 컴파일러와 자바 바이트코드    
자바 컴파일러에 의해서 생성되는 코드를 __자바 바이트코드__ 라고 한다. 자바 컴파일러에 의해 생성되는 코드의 명령어 크기가 1바이트 이기 때문이다.     
과정을 살펴보면 자바의 소스코드가 __javac.exe__ 에 의해서 컴파일되고, 해당 파일이 __java.exe__ 에 의해서 가상머신을 기반으로 실행이 되는 것이다.      

## 프로그램의 골격과 구성 
클래스 이름이 Myclass이면 컴파일시 생성되는 파일의 이름은 Myclass.class이다. 

# 자바 기본 공부 2
## 변수
- 변수 : 데이터의 저장과 참조를 위해 할당된 메모리 공간    
- 자바에서 제공하는 기본 자료형 : boolean, char, byte, short, int, long, float, double     
- 실수의 표현에서 오차가 존재한다. 
    - 정밀도를 포기하고 표현의 범위를 넓히고자 했었다. 
    - float와 double을 선택할 때에도 정밀도를 기반으로 채택 
    - float는 6자리의 정밀도, double은 15자리의 정밀도를 가지고 있다. 
    - 큰 실수형을 표현하기 위해, e를 사용함. (e-3 은 10의 -3승을 의미한다.)
- 자바는 정수형 연산을 진행할 때, 모든 피연산자를 int형으로 변환하는 과정을 거친다. (int형이 정수연산을 가장 고속으로 처리하게끔 설계되어있기 때문 - int보다 작은 레벨의 자료형에서만, long은 int로 변환되지 않음)
- 변수의 이름 제한사항 
    - 변수의 이름은 숫자로 시작할 수 없음 
    - $와 _ 이외의 다른 특수문자 사용 불가. 
    - 키워드(자바의 문법을 구성하는 단어들)는 변수의 이름으로 사용 불가.    
- 문자 : 자바는 유니코드라는 표준을 근거로 문자를 표현한다. 그래서 자바에서 문자 하나를 변수에 저장하면 실제로는 해당 문자의 유니코드 값이 저장되는 것이다.     
    - 문자는 작은 따옴표로 표현이 된다. 

# 자바 기본 공부 3
## 상수와 형 변환 
- 상수 : 메모리 공간에 값이 저장은 되지만, 변수와 달리 저장된 값의 변경이 불가능하다. (변수와 달리 이름이 없기 때문에 메모리 공간에 접근 하지 못하므로)    
- 기본적으로 모든 정수형 상수는 int형으로 표현 및 저장한다. 그렇기 때문에 long num = 10000000 으로 하면 에러가 난다. int로 표현 저장하기 때문이다. 그래서 10000000L 로 표기해서 이정수를 long형으로 표현해달라고 해야한다. 
- 기본적으로 모든 실수형 상수는 double형으로 표현 및 저장한다. 이것도 마찬가지고 float num = 12.45로 하면 에러가 난다. 12.45F로 표현해야 한다. 
- 연산을 할때에는 자료형을 한개로 통일시켜 주어야 한다. --> 자바에서는 '자동 형 변환' 이라는 과정을 통해 CPU가 연산을 할 수 있도록 자료형을 하나로 일치시켜 준다. 
![자동형변환]()
- 가급적이면 자동으로 형 변환이 발생하는 위치에 명시적으로 형 변환이 됨을 표현하는 것이 좋다.    

# 자바 기본 공부 4 
## 연산자 
- 이항 연산자 : 피연산자가 두개인 연산자
- 연산자들의 우선순위로 인한 실수를 줄이기 위해 소괄호를 이용하는 경우가 많음. 
- 실수를 이용한 % 연산의 결과는 의미가 없으니 이런 연산문은 만들지 않도록 하는게 중요하다.    
- short circuit Evaluation (SCE = Lazy Evaluation): 가장 빠르게 연산을 진행하기 위한 계산 방식
    > SCE 코드를 통해 설명해둠. 
- 비트 연산자(&, |, ^, ~)의 피연산자는 반드시 정수여야 한다. 실수에 대해서는 비트연산이 불가능하다. 
- 비트연산자는 비트단위로 연산을 진행하고 그 연산의 결과를 묶어서 하나의 연산결과를 반환한다. 

# 자바 기본 공부 5 
## 살행흐름의 컨트롤 
- 조건문 
- 조건 연산자 : < true or false ? 숫자1 : 숫자2 > 로 표현한다. 
    - ? 왼편에 true가 등장하면 숫자1이 반환된다. 
- switch문 : switch, case, default, break로 구성됨. break가 없으면 모든 문장을 다 거치고 break가 있다면 거기서 switch문은 끝이 난다. 
- while 반복문 
    - 반복조건을 먼저 검사한 후에 반복영역의 실행여부를 결정한다. (검사결과가 true이면 반복영역이 실행됨)
    - 반복조건을 먼저 검사하기 때문에 반복영역이 한차례도 실행되지 않을 수 있다. 
    - 무한루프에 빠지지 않도록 조심해야한다. 
- do~while 반복문 
    - while 반복문과 다르게 반복영역이 한번은 무조건 실행됨. 
- for 반복문 
    - 반복변수를 초기화한후 반복조건이 만족되었는지 확인후 만족되었으면 반복영역을 실행함. 
    - 반복영역이 실행된 후 변수의 값이 작성된 것에 기반하여 변화한다. 
- break 
    - 가장 가까이에있는 반복문 한개를 빠져나가기 위한 용도로 사용됨. 
    - 상황에 따라 중첩된 반복문 모두를 나가야 하는 경우도 발생한다. 이럴때는 outerLoop : for(~,~,~) 로 반복문을 설정하고 , 빠져 나오고 싶은곳에 break outerLoop 를 써서 빠져나오면 된다. 
- continue
    - 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건검사 부분으로 이동시킴. 
 
# 자바 기본 공부 6
## 메소드와 변수의 스코프 

### 메소드 
- 자바 프로그램의 시작은 main이라는 이름의 메소드를 실행하는 데서부터 시작한다. 
- 프로그램 진행중, 메소드 호출문을 접하면, 해당 메소드의 실행이 완료된 다음에야 비로소 그 다음을 실행하게 된다. 
- 메소드가 정의되는 위치는 프로그램에 영향을 미치지 않음 
- 매개변수(parameter) : 메소드 이름 오른쪽 
    - 메소드 호출 시 전달되는 값의 저장을 위한 용도로 사용됨 --> 그래서 메소드 호출 시 전달되는 값의 자료형과 매개변수의 자료형은 일치해야함
- 반환 : 메소드 이름 왼쪽에 자료형은 반환값의 자료형 
    - void : 값을 반환하지 않는다. 
    - return 문을 실행하게 되면 메소드는 종료가 되고 메소드를 호출한 영역으로 값은 반환이 된다. 
    - 오직 한개의 값만 반환할 수 있다. 
    - return 이 가지는 2가지 의미 
        - 값의 반환 & 메소드의 종료
        - void에서도 return; 을 사용해 메소드 종료 가능 
        
        
### visibility 
- 지역변수 
    - 중괄호로 영역이 형성되면, 감싸이는 영역은 변수에 관한 별도의 스코프를 형성함. 
    - 변수는 자신이 속한 중괄호 내에서만(선언된 이후부터) 접근이 가능하다. --> 속한 영역이 다르면 이름이 동일할지라도 문제가 되지 않음
    - for문의 일부로 선언되는 변수, 메소드의 매개변수도 이어서 등장하는 중괄호 내에서만 접근이 가능하다. --> 그래서 매개변수에서 num이라는 변수를 사용했다면 그 중괄호 안에서는 이제 그 이름의 변수를 쓸수없다. 
    - 지역변수는 선언된 지역을 벗어나 버리면 메모리 공간에서 자동 소멸된다. 
    
### 메소드의 재귀호출 
- 아직 실행이 완료되지 않은 메소드를 어떻게 다시 호출하나?
    - 메모리에 저장된 메소드를 구성하는 명령문은 CPU로 이동해서 실행이 된다.
- 잘못된 재귀 메소드의 정의 --> 종료조건이 없다...!
    예시) InfRecul class 코드를 보면 cnt를 감소시켜 주기는 하지만 cnt--로 감소시켜 주어서 메소드가 호출이 된다음에야 감소된다. 
        그래서 이 코드는 무한히 돌게되는 것 --> --cnt로만 바꾸어도 해결가능 
        but 이렇게 한다고 해도, 재귀는 계속된다. 9-10행이 실행되지 않기 때문이다. 
        이것들의 위치를 8행과 바꾸면된다. 
        
    - 재귀의 연결 고리를 끊기 위한 조건검사의 위치가 적절해야한다.
    - 재귀의 연결 고리를 끊기 위한 조건검사가 true가 될 수 있도록 적절한 연산이 이루어져야 한다. 
 - 과도한 재귀의 사용은 메모리를 너무 많이 사용하게 하여 성능저하를 일으킬 수 있다. 
 
 # 자바 기본 공부 7
 ## 클래스와 인스턴스 
 
 ### 클래스의 정의와 인스턴스의 생성
 - 객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화시키는 형태의 프로그래밍. 
 - 객체를 이루는 것은 '데이터' & '기능'
 > 나는 과일장수에게 2000원을 주고 두개의 사과를 구매했다       

 위의 문장을 객체화하는 연습을 해보겠다 
 1. 객체 나누기 
    - 나, 과일장수, 사과 가 될 수 있다. 
    - 나, 과일장수만 객체로 인식하여 문제를 풀어보겠다
    
 2. 과일장수 객체를 이루는 것 
    - 과일장수는 과일을 판다. ---> 과일장수의 행위 <기능>
    - 과일장수는 사과 20개, 오렌지 10개를 가지고 있다. ---> 과일장수의 상태 <데이터>
    - 과일장수의 과일판매 수익은 50000원이다. 
    
    상태정보는 변수를 통해 표현되고, 행동은 메소드를 통해 표현된다. 
    
    - 변수 
        - 보유하고 있는 사과의 수 : int numOfApple;
        - 판매 수익 : int myMoney
    
    - 메소드 
        int saleApple(int money){       // 사과 구매액이 인자로 전달됨 
            int num = money / 1000;     // 사과 한개당 1000원이라고 가정 
            numOfApple -= num           // 팔린 사과의 수만큼 보유중인 사과수 줄이기 
            myMoney += money            // 판매 수익 발생 
            return num                  // 실제 구매가 발생한 사과의 수를 반환
        }
        
 3. 과일장수 클래스 정의 --> class라는 틀을 기반으로 객체 생성 
    - 객체를 생성하기 앞서 객체의 생성을 위한 틀(mold) 만들어야함. 틀 = class 
    - FruitSeller 라는 틀을 정의
        class FruitSeller
        {
            // 변수 선언 
            int numOfApple = 20;
            int myMoney = 0;
            
            // 메소드 정의 
            public int saleApple(int money)
            {
                int num = money / 1000;
                //동일클래스에 해당 변수가 있으므로 접근 가능 
                numOfApple -= num;
                myMoney += money;
                return num;
            }
        }
        
 4. 메소드 추가해보기 
    - 남은사과와 판매수익을 보여주는 메소드 추가 
                class FruitSeller
                {
                    // 사과가격
                    final int APPLE_PRICE = 1000;
                    // 변수 선언 
                    int numOfApple = 20;
                    int myMoney = 0;
                    
                    // 메소드 정의 
                    public int saleApple(int money)
                    {
                        int num = money / 1000;  ---> int num = money / APPLE_PRICE; 
                        //동일클래스에 해당 변수가 있으므로 접근 가능 
                        numOfApple -= num;
                        myMoney += money;
                        return num;
                    }
                    
                    // 추가된 메소드
                    public void showSaleResult()
                    {
                        System.out.println("남은사과: " + numOfApple);
                        System.out.println("판매수익: " + myMoney);
                    }
                        
                }      
    - final 변수
        - 변수가 상수화 된 것이기 때문에 final 상수라고도 부름 
        - 한번 값이 결정된 이 변수의 값은 변경이 불가능하다. 
        - 지역변수가 final 로 선언되면 딱 1번 초기화가 가능하다. 
                
 5. 나 클래스 정의
     - 변수 
         - 소유하고 있는 현금 : int myMoney
         - 소유하고 있는 사과의 수 : int numOfApple 
        
        class FruitBuyer
        {
            int myMoney = 5000;
            int numOfApple = 0;
            public void buyApple(FruitSeller seller, int money)
            {
                numOfApple+=seller.saleApple(money);
                moMoney-=money;
            }
            public void showButResult()
            {
                System.out.println("사과개수: " + numOfApple);
                System.out.println("현재잔액: " + myMoney);
            }
            
 6. 클래스 기반으로 객체 생성하기 
    - 객체 생성 방법 : ClassName name = new ClassName();
        - ClassName 객체를 생성하고 이를 name이라는 이름의 변수로 참조한다 라는 의미 (name : 참조변수)
        - new에 의해 객체 생성시 생성된 객체는 메모리에 저장되고, 저장된 메모리의 주소값(참조값)이 반환되어 참조변수에 저장된다.          
        - 그래서 참조변수에 의한 객체 접근이 가능한 것.
        - new 키워드 : 객체 생성을 명령하는 명령어
    - 이렇게 객제를 생성하는 행위를 가르켜 '인스턴스화' 라고 한다. 
    - 이렇게 생성이 된 객체를 '인스턴스' 라고 부른다. 
    - 클래스 & 객체 --> 메모리 관점에서 보면 매우 차이 있음 
        - 클래스에 존재하는 변수와 메소드는 메모리 공간에 할당된 형태로 존재하지 않음 --> 접근도 호출도 불가능한 상태 
        - 객체는 메모리 공간에 할당이 이루어짐 
    - 클래스를 정의하는 것은 자바에서 제공하는 기본 자료형 이외에 프로그래머가 새로운 이름의 자료형을 정의하는 것.
        
        - 예시)
            FruitSeller seller1 = new FruitSeller();
            instMethod(seller1);
            
            public void instMethod(FruitSeller seller2)
            {
                ....
            }
            --> 여기서 매개변수로 선언된 seller2에 seller1이 저장하고 잇는 객체의 참조값이 전달된다. 즉, 참조변수 seller1과 seller2가 하나의 객체를 동시에 참조하는 상황.
 
 - 하나의 객체가 다른 하나의 객체에게 메시지를 전달하는 방법은 메소드 호출을 기반으로 한다. 그래서 객체지향에서는 이러한 형태의 메소드 호출을 가리켜 '메시지 전달' 이라고 한다. 
 - 특정 개체로 초기화가 이뤄지지 않는다면 null로 초기화 할 수 있다. 

 ### 생성자 (Constructor)
 - 위에서 진행했던 과일장수 문제를 확장해서 과일장수가 2명 있다고 생각해보자 
 - 과일장수마다 사과의 가격이 다를 것이기 때문에 final APPLE_PRICE 로 정의한 부분이 문제가 된다. 
 - final로 사과가격을 지정하는 것이 아니라, 인스턴스를 생성하고 나서, 인스턴스 변수를 각각 초기화 하는 방식을 사용해야 한다. 
 
 - ch7의 Fruit2.java를 확인해보면 2가지 문제점이 있다는 것을 알수 있다. 
    1. 인스턴스를 생성하고 난 다음에 초기화하는 작업을 해야한다. 한번에 생성과 초기화가 되지 않고 두줄에 걸쳐 해야함
    2. 인스턴스 변수 APPLE_PRICE의 final 선언이 사라짐 (인스턴스 생성 이후 변경되지 않을 인스턴스 변수를 final로 선언함으로써 프로그램의 안전성을 향상시켰었음)
        초기화가 이루어지지 않은 final 변수는 한번의 초기화 기회를 가진다. 
        하지만 인스턴스 메소드는 두번 이상 호출될 수 있다. 
        그러므로 인스턴스 메소드 내에서 final 변수의 값을 초기화하는 행위가 허용되지 않는 것이다. 
        그러타면 딱한번만 호춛되는 메소드는? --> 생성자      
 
 - 생성자 
    - 생성자가 되기 위한 조건 
       1. 클래스의 이름과 동일한 이름의 메소드 
       2. 반환형이 선언되어 있지 않으면서, 반환하지 않는 메소드 
    - 생성자는 인스턴스 생성시 딱 한번 호출되는 메소드
    - Number num1 = new Number() --> new의 오른편에 있는 부분이 인스턴스의 생성과정에서 호출될 생성자를 명시하는 부분. 
        new Number --> Number의 인스턴스 생성 / Number() --> Number() 생성자 호출
    ---> "자바의 인스턴스 생성시에는 반드시 생성자가 호출되어야한다." 
    
    - 값을 전달받는 생성자 --> 이것이 있으므로 생성자를 이용해 인스턴스 변수의 초기화를 수월하게 할 수 있음을 깨닫게 됨 
    
 - Fruit2.java를 위에서 배운 값을 전달받는 생성자를 이용해 발전시켜보자 
 - 생성자가 없어도 인스턴스 생성이 가능한 이유 : 디폴트 생성자 (인자를 받지 않으면 하는 일이 아무것도없음)
 
 ### 자바의 이름 규칙 
 - 클래스의 이름 규칙
    - 'Camel Case'
        첫 문자는 대문자로 시작한다. 
        둘 이상의 단어가 묶여서 하나의 이름을 구성할 때, 새로 시작하는 단어는 대문자로 한다. 
        
 - 메소드와 변수의 이름 규칙 
    - 첫문자를 소문자로 시작하는 Camel Case방식을 사용한다. 
    
 - 상수의 이름 규칙 
    - 상수와 변수를 구분할 수 있도록 모든 문자를 대문자로 구성하는 것이 관례
    - 둘 이상의 단어가 연결되어야 하는 경우에는 _(언더바)를 사용한다. 
    
 # 자바 기본 공부 8 
 ## 클래스 패스와 패키지 
 
 ### 클래스 패스(class path)의 지정 
 - classpathtest 디렉토리 안에 java파일을 저장하고 컴파일 한후 
 - java파일의 일부인 class를 classpathtest의 서브클래스 mysubclass를 만들어 옮긴후 실행하면 문제가 발생한다. 
 - java.exe를 실행한 디렉토리에서만 가상머진에 올려질 클래스를 찾기 때문이다. 
 - 이때는 'java.exe를 실행시킨 현재 디렉토리의 서브 디렉토리인 mysubclass 디렉토리에서 클래스를 찾아보세요' 라는 메세지를 전달해야 한다. 
 - 위에서 말한 메세지는 '환경변수'라는 것을 이용해서 전달해야 한다. 
    - 환경변수 
        내가 만든 디렉토리인 classpathtest에 calc.exe가 존재 하지 않지만 classpathtest디렉토리에서 실행시켜 보면 실행이된다. --> 이것은 환경변수 path에 의해서 가능한 일이다. 
        환경변수 path에 저장된 정보가 무엇인지 확인해 보자 --> echo %path%로 확인가능 
        긴 문자열을 확인할 수 있다. 세미콜론에 의해서 데이터가 구분된다. 구분된 이 경로들은 모두 cmd에서 프로그램을 실행시킬 때, 해당 프로그램의 실행파일을 찾는 경로 정보로 활용됨
        환경변수라는 것은 path만 있는게 아님. 필요에 따라 추가할 수 있는 것이 환경변수. --> 자바에서는 클래스의 검색 경로를 지정할 수 있도록 classpath라는 환경변수를 정의하고 있다. 
        그래서 결론적으로 클래스의 경로정보를 classpath라는 환경변수에 추가함으로써 클래스의 검색경로를 확장할 수 있다. 
 - classpathtest 디렉토리에서 echo %classpath% 를 확인한다. 
 - set classpath=.; --> 이런식으로 classpath에 추가한다. 
 
 ### 패키지의 이해 
 - 기능만으로 클래스를 나누는 것은 제대로 된 클래스의 설계방식이 아니다. 
 - circle 문제를 이용해서 알아봄 
    - 한 팀은 둘레구하는 클래스 / 한 팀은 넓이 구하는 클래스 만들기로 함 
    - 만들어서 합치려고 보니 같은 class 이름을 사용함 
    - 우선, 컴파일부터 안되지만 디렉토리를 다르게 하여 컴파일한후 main에서 인스턴스를 생성할 때 제대로 생성되지 않을것이다. 
    
    --> 해결책 2가지 
        1. 컴파일 완료된 동일한 이름의 클래스 파일을 서로 다른 디렉토리에 저장한다. 
        2. 인스턴스 생성 시, 저장되어 있는 디렉토리 정보를 표시해서 클래스를 구분하게 한다. 
        
        orange.area.Circle. c1 = new orange.area.Circle();
        orange.perimeter.Circle. c1 = new orange.perimeter.Circle();
        --> orange : 패키지 (= 디렉토리) / area,perimeter : 서브패키지(= 서브디렉토리) 
        --> 패키지는 단순히 디렉토리를 나누는 개념이 아님. 패키지는 소스파일에 별도의 선언을 통해 만들어짐. 
        --> area 디렉토리에 존재하는 circle 클래스와 perimeter 디렉토리에 존재하는 circle 클래스를 각각 패키지 선언이라는 것을 통해 패키지의 개념으로 묶어주어야함 
        
 - 패키지와 클래스 패스의 관계
 
 - 패키지의 선언 
    - '이 클래스는 orange.area' 패키지에 묶겠다. 
        => package orange.area;
    - ch8 파일을 잘 확인해보면 패키지 구분이 되어 있는것을 확인할 수 있다. 
    
    
 # 자바 기본 공부 9
 ## 접근제어 지시자와 정보은닉, 그리고 캡슐화 
 
 ### 정보은닉 
 
 ### 객체지향 관점에서 빵점 
 - ch9 의 Fruit4를 보면 말도 안돼는 상황에 맞닥뜨리게 됨 
 - 그 이유 --> 외부에서 인스턴스 변수를 접근할 수 있기 때문 
 - 인스턴스 변수를 private를 사용하면됨 --> 프로그램의 안정성 높아짐  (인스턴스 변수는 정보은닉의 대상)
 
 ### 접근제어 지시자 
 - public, private, protected, 선언하지 않음 --> 4종류가 있음 
 - 인스턴스 변수는 정보은닉의 대상 but 이변수의 간접접근을 허용하기 위해 추가적인 메소드를 제공 = Access 메소드 
    Access 메소드 => setXXX() : 값을 변경하는 메소드 , getXXX() : 값을 반환하는 메소드 
 - 접근제어 지시자를 선언하지 않은 경우 (default)
 - 접근제어 지시자에 의한 접근 허용여부는 인스턴스가 아닌 클래스를 기준으로 따진다.
 - protected = default + 알파 
    --> default는 허용하지 않지만 protected는 허용하는 알파가 있다. 
    --> 상속의 개념이 빠지면 default와 다를바 없다. 
    --> 상속을 받는 클래스의 접근을 허용하는 지시자. 
    
 | 지시자 | 클래스 내부 | 동일 패키지 | 상속받은 클래스 | 이외의 영역
 | :--- | :---: | ---: | ---: | ---:|
 | private | O | X | X | X |
 | default | O | O | X | X |
 | protected | O | O | O | X |
 | public | O | O | O | O |
 
 ### public 클래스와 default 클래스 
 - public 클래스 
    - 하나의 소스파일에는 하나의 클래스만 public으로 선언할 수있다. 
    - public 클래스의 이름과 소스파일의 이름은 완전히 일치해야 한다. 
    --> 위와 같이 표기하는 이유 : 기능을 이해하는데 중요한 역할을 하는 public 클래스와 소스파일의 관계를 형성하기 위함.
 - 생성자도 private으로 선언할 수 있다. 이렇게 되면 클래스내부에서만 생성자 호출이 가능해진다. 이는 결국 외부에서의 인스턴스 생성을 허용하지 않겠다는 뜻이다. 
 - 디폴트 생성자 : 매개변수가 없는 생성자 
 
 #### 어떤 클래스를 public으로 선언할까
 - 필요한 상황에서는 반드시 클래스를 public으로 선언해야 한다. 
 
 #### 자바의 라이브러리는 클래스로 이루어져 있음
 - package orange.cal 의 calculator.java 참고
 - 일반적으로 라이브러리 형태의 클래스들을 정의한 때에는 최소한의 클래스만 public 으로 선언한다. 
 
 ### 캡슐화
 - 예를 들면 콘텍600 --> 재채기 콧물 코막힘 완화 --> 이것이 한개의 캡슐에 있음
                     --> 재채기 콧물 코막힘 이라는 각각의 캡슐이 3개가 있다면 캡슐화 아님 
 - 정보은닉과 캡슐화를 다른 개념이라고 인식하고 접근하자
 - 캡슐화를 한다고 해서 하나의  클래스로만 모든것을 구성해야하는 것은 아니다. 다른 클래스를 활용해도 됨. 
 
 # 자바 기본 공부 10 
 ## 클래스 변수와 클래스 메소드 
 
 ### static 변수 (클래스 변수)
 - 인스턴스 변수 : 인스턴스가 생성되었을 때 접근이 가능한 변수이기 때문에 인스턴스 변수 
 - 클래스 변수는 클래스가 정의만 되어도 접근이 가능한 변수이기 때문에 클래스 변수 
 
 - static으로 선언된 변수는 변수가 선언된 클래스의 모든 인스턴스가 공유하는 변수이다. 
    --> 인스턴스 변수가 인스턴스 별로 각각 존재하는 변수라면, static변수는 딱 한개만 존재해서 모든 인스턴스가 공유하는 형태의 변수
 - static 으로 선언된 변수는 메모리 공간에 하나만 존재하며, 어디서나 접근이 가능한 변수이다. 단 어디서나 접근이 가능하려면 static 변수도 public으로 선언되어야 한다. 
    
 - static변수는 클래스내부에서뿐만 아니라, 외부에서도 접근이 가능한 변수 
 - static변수는 인스턴스가 생성되기 이전에 별도의 메모리 공간에 할당되어 초기화까지 완료된다. 
    - 정확한 시점은 언제?
    - 자바는 컴파일이 완료되고 나서 하나의 실행파일이 만들어지는 것이 아닌, 여러개의 클래스 파일들만 생성됨. 
    - JVM은 실행되는 과정에 따라 필요한 클래스만 메모리 공간에 올려서 프로그램을 실행한다. (유연함, on-demand 실행 방식)
    --> 결론 ) static 변수가 초기화되는 시점은 JVM에 의해서 클래스가 메모리 공간에 올라가는 순간이다. 
    --> 그렇기 때문에 static 변수를 생성자를 통해서 초기화하면 안됨. 그러면 인스턴스가 생성될 때마다 새로운값이 대입되는 꼴.
    
 - static 변수의 활용
    - 인스턴스간에 데이터 공유가 필요한 상황에서는 static 변수를 선언한다. 
    - 클래스 내부 또는 외부에서 참조의 용도로만 선언된 변수는 static final 로 선언한다. 
    
 ### static 메소드 (클래스 메소드)
 - static 변수와 마찬가지로 인스턴스 이름을 이용한 호출, 클래스이름을 이용한 호출 모두 가능하다. 
 - 인스턴스를 생성하지 않아도 static 메소드를 호출 할 수 있다. 
 - 인스턴스 단위로 진행해야 할 일들이 존재하지 않는다면 (인스턴스 변수에 접근하지 않는다면), 이는 인스턴스 메소드가 아닌 static 메소드로 정의해야 하는 상황임. --> 그래야 인스턴스를 생성하는 일없이 간결히 코드 작성 가능 
 
 - static 메소드 내에서는 static 변수나 static 메소드가 아닌 인스턴스 변수나 인스턴스 메소드의 접근이 불가능하다. 
    class AAA
    {
        int num1;
        static int num2;
        static void changeNum()
        {
            num1++; // 문제 발생 
            num2++; // 문제 없음 
        }
    }
    
    --> 문제가 발생하는 이유 ) 만약 AAA인스턴스가 3개 만들어진다고 하면 각 인스턴스는 num1을 가지고 있는 상황
                                그러나 인스턴스 3개가 changeNum() 1개를 공유하고 있음. 
                                그래서 changeNum()에서 num1을 증가시키면 3개의 num1 중 어느것을 증가시켜야 하는지 불분명 
                                --> 그래서 접근이 불가능 한것 
    
 ### System.out.println & public static void main
 - System.out.println
    - System : java.lang 패키지에 묶여있는 클래스 이름 
    - println : 메소드
    - out : 클래스 이름을 통해 접근하니 static 변수이다. println이라는 메소드를 호출하는 걸 보니, static 변수이자 참조변수이다. 
    
 - public static void main
    - main 메소드는 어디든 존재할 수 있음(문법적으로 문제 없다.) (다만 실행을 시킬때 main메소드가 있는 클래스를 실행시켜 주어야 함)
    - main 메소드는 인스턴스의 생성과 상관없이 JVM에 의해 호출이 되므로 (핵심), 반드시 static으로 선언해야 한다. 
 
 - 메소드는 자신이 속해있는 클래스의 인스턴스 생성이 가능하다. (그래서 main메소드가 어디든 존재할 수 있는 것)
    class AAA
    {
        public static void makeAAA()
        {
            AAA a1 = new AAA();
        }
    }
    --> 가능 
    
 # 자바 기본 공부 11
 ## 메소드 오버로딩과 String 클래스 
 
 ### 메소드 오버로딩 
 - 매개변수의 형(type)이 다르거나 개수가 다르거나 
 - 반환형이 다른 것은 메소드 오버로딩이 성립되지 않음 
    ex) int isYour(int n){}  && boolean isYour(int n){} 
 - 자바의 생성자는 오버로딩을 지원한다. --> 생성자의 오버로딩으로 인해 하나의 클래스를 기반으로 다양한 형태의 인스턴스 생성이 가능해진다. 
 - 오버로딩 된 메소드는 대부분의 경우 상당히 유사하게 정의된다. 
    따라서 오버로딩 과정에서 중복되는 코드의 삽입이 부담스러움 
    그러나 메소드 내에서는 오버로딩된 다른 메소드의 호출이 가능하기 때문에, 이런 코드 중복문제 쉽게 해결 
 - 오버로딩된 생성자를 생각해보자 
    생성자의 경우, 인스턴스의 생성과정에서만자동으로 호출될 뿐 그 이외의 영역에서는 명시적으로 호출할 수 있는 대상이 아님. 
    그래서, 생성자에 한해서 (only 생성자) 오버로딩 된 다른 생성자의 호출을 허용한다. --> this 라는 키워드 이용 (예제 확인)
        * this 의 사용 형태 3가지 
            1) 클래스의 속성과 생성자/메소드의 매개변수의 이름이 같은경우 (클래스 속성을 사용할때 this 키워드를 붙여줌)
            2) 클래스에 오버로딩된 다른 생성자 호출 
            3) 객체 자신의 참조값을 전달하고 싶을 때 
            
            // class SimpleAdder 안의 메소드
            public SimpleAdder add(int num)
            {
                this.num += num;
                //자기 자신을 참조할 수 있는 참조 값이 반환
                return this;
            } 
            --> 이 메소드의 반환형이 SimpleAdder. 
 
 ### String 클래스 
 - 자바는 문자열도 인스턴스로 처리하기 위해서 String이라는 이름의 클래스를 정의하고 있음. 
 - 지금까지의 인스턴스는 new를 이용하여 생성했지만, String의 인스턴스는 큰따옴표만으로 생성 가능. 
    ex) String str = "String instance";
    ex) System.out.println("Hello world") --> 여기서도 String인스턴스가 생성되어 메소드의 인자로 전달되는 것이다. 
                                              println 메소드의 매개변수형이 String인것. 
 - str.length() --> length라는 메소드를 호출함 --> str이 인스턴스임을 증명하는 증거. 
   "해해해".length(); == (new AAA()).bbb(); 
 - String 클래스의 인스턴스는 상수의 성격을 지니다. --> String의 인스턴스에 저장된 문자열데이터의 변경이 불가능하기 때문.
 - String인스턴스는 배열을 기반으로 큰 타옴표로 명시된 문자열 데이터를 저장하게 된다. 
 - 자바는 인스턴스 생성의 수를 줄이기 위해서 동일한 문자열 데이터로 구성되는 String 인스턴스의 생성을 하나로 제한한다. 
    그리고 이를 통한 문제의 발생을 막기 위해서 String 인스턴스의 데이터 변경은 허용하지 않고 있다. 
 
 ### API Document의 참조를 통한 String 클래스의 인스턴스 메소드 관찰 
 - 메소드들에 대해 반드시 API문서상에서 다시 한번 확인하는 습관을 들려라. (java.sun.com)
 - 문자열 복사 )
    String str1 = "LEMON";
    String str2 = "LEMON";
    String Str3 = new String(Str2)
    --> str1 & str2 는 같은 인스턴스를 참조한다. 
    --> 별도의 인스턴스에 저장하기 위해 3번째줄과 같이 해줌 , str2와 str3은 다른 인스턴스를 참조한다(같은 문자열임에도 불구하고)
 - 문자열의 + 연산 
    - String str4 = "Lemon" + 'A' --> String.ValueOf('A')  (매개변수를 문자열로 만들어주는 메소드) 가 호출된다. 그리고 문자열2개를 결합하는 concat() 메소드가 호출되는것.
    - + 연산이 많으면 그 개수만큼 인스턴스가 만들어진다? No. 그렇게 되면 너무 부담 커짐 --> 자바 컴파일러는 문자열결합의최적화를 수행해서 아무리 많은 + 연산이더라도 추가적 인스턴스 생성은 2개로 제한된다. 
    ex) String str5 = 1+"Lemon" + 3;
        --> String str5 = new StringBuilder().append(1).append("Lemon").append(3).toString();
        --> new StringBuilder() : 이부분에 의해 인스턴스 하나가 생성됨.
            그리고 append() 메소드가 호출됨. 
            new StringBuilder().append(1).append("Lemon").append(2) : 여기까지하면 1Lemon3 을 버퍼에 저장하는 StringBuilder 인스턴스가 완성되는것 
            우리는 String 인스턴스를 원함 그래서 toString() 로 String 인스턴스 생성. 
            그래서 총 2개의 인스턴스가 생성되는 것.
        
 ### StringBuilder & StringBuffer 클래스 
 - StringBuilder 와 StringBuffer 는 변경이 가능한 문자열의 표현을 위한 클래스. 
 - String으로 된 문자열을 변경할 일이 있다면, StringBuilder strb = new StringBuilder(string으로된 문자열) --> 이런식으로 하여 StringBuilder에 복사한 후 변경하면됨.
 
 - StringBuilder
    - 이것은 문자열의 저장, 변경을 위한 메모리 공간(버퍼)을 내부에 지님.
    - 주요 메소드 ) append, insert
        * append (인스턴스 자신의 참조값(this)을 반환함)
            // class SimpleAdder 안의 메소드
            public SimpleAdder add(int num)
            {
                this.num += num;
                //자기 자신을 참조할 수 있는 참조 값이 반환
                return this;
            } 
            --> 이 메소드의 반환형이 SimpleAdder.   
            --> main 메소드에서 
                SimpleAdder adder = new SimpleAdder();
                adder.add(1).add(3).add(5).showResult();
                --> adder.add 메소드의 반환값이 adder이기 때문에 반환되는 참조값을 통한 메소드의 호출이 가능한것이다. 
    - 이 메모리공간의 크기는 자동조절됨
        - public StringBuilder() //16개의 문자 저장 버퍼 생성
        - public StringBuilder(int capacity) // capacity 개의 문자 저장 버퍼 생성 
    
        - 버퍼크기 확장하는 작업은 많은 연산이 요구됨. 그래서 가급적이면 필요로하는 버퍼의 크기를 미리 할당하는 것이 성능에 도움됨. 
 
 - StringBuffer
    - StringBuilder와의 차이점 --> StringBuffer는 쓰레드에 안전하지만, StringBuilder는 쓰레드에 안전하지 못하다. 
    
 # 자바 기본 공부 12 
 ## 콘솔 입력과 출력 
 
 ### 콘솔 출력 
 - System.out.println 와 System.out.print
    - 위 두개의 메소드에서 인자로 문자열이 아닌 인스턴스의 참조값이 전달되면, 해당 인스턴스의 toString 메소드를 호출하여, 이때 반환되는 문자열을 출력한다.
        class Friend{
            ...
            // 여기에서 문자열이 반환된다고 하였는데 실제 반환되는 것은 return 이후에 나온 것("제이름은 " + myName + "입니다.")에 의해서 생성된 인스턴스의 참조값이 반환되는 것이다. 
            public String toString(){
                return "제이름은 " + myName + "입니다.";
            }
        }
        Friend fri1 = new Friend("김보원");
        System.out.println(fri1);
 - 이스케이프 시퀀스 
    - ＼ 로 시작한다. 
    - ＼n ＼t ＼"(큰따옴표) ＼＼(역슬래쉬)
 - System.out.printf
    - %d(10진수 정수) %f(실수) %c(문자 'A') %s(문자열) %e(e표기법) %g(출력대상에 따라 %e,%f로 출력)
    - e 표기법 : 1.7 X 10의 -10승 --> 1.7e-10 
 ### 콘솔 입력
 - Scanner class 
    - java.util 패키지에서 제공하는 클래스 
    - Scanner는 키보드의 입력을 위해서만 디자인된 클래스가 아니다. 
         Scanner(File source) , Scanner(InputStream source), Scanner(Readable source), Scanner(String source)와 같이 여러개의 생성자가 있음 
    - Scanner는 모든 공백(스페이스 바, 탭, 엔터 의 입력)이 데이터를 구분하는 기준이 된다. 
 
 * 매개변수는 메소드를 나오면 소멸된다. 
 
 # 자바 기본 공부 13
 ## 배열 (Array)
 
 ### 배열이라는 존재가 필요한 이유 
 - 배열의 선언은 둘 이상의 변수 선언에 편의를 제공한다. 
 - 배열로 선언된 변수들에는 반복문을 이용해서 동ㅇㄹ한 코드 패턴을 적용할 수 있다.
 
 ### 1차원 배열의 이해와 활용 
 - 문자열이 인스턴스 이듯, 배열도 인스턴스이다. 
 - 배열의 참조변수 선언
    int [] ref; --> int형 변수로 이루어진 배열,의 참조변수 ref 
 - 배열은 기본 자료형으로만 선언해야 하는 것 아님. 클래스 기반으로도 생성 가능 
    FruitSeller [] arr1 = new FruitSeller[5]; 
        --> 배열 안에는 다섯개의 FruitSeller클래스형 변수가 존재한다. & 인스턴스 변수(length)도 존재한다. 
 - 주의 ) 인스턴스 배열은 '참조변수의 배열'. 인스턴스로 이루어진 배열이 아니라, 인스턴스의 참조값을 저장할 수 있는 참조변수로 이루어진 배열. 
 - 선언과 동시에 초기화 가능 
    - int[] arr = new int[3] {1,2,3}; --> 초기화할 값들을 중괄호안에 나열하면 된다. 
    - int[] arr = {1,2,3}; --> 이렇게 줄여쓰는것이 관례
 
 ### 다차원 배열의 이해와 활용 
 - 2차원 배열 
    - int[][] arr2 = new int[5][8];
        --> 5 : 세로의 길이 / 8 : 가로의 길이 
    - 인스턴스 변수 (length) 사용 
        --> arr2.length; 배열의 세로 길이 
        --> arr2[1].length; 배열의 각행 길이로 사용 
    - 선언과 동시에 초기화 
        - int[][] arr = {
            {1,2},
            {5,6,7},
            {9,10,11,12}
          };
        --> 이런식으로 하게 되면, 1행의 길이는 2, 2행의 길이는 3, 3행의 길이는 4인 행의 길이가 일정하지 않는 2차원 배열이 생성된다. --> Ragged Array 라고 함.
    - 행과 열을 분리하여 선언하는 것 가능 
        - int [][] arr = new int[3][]; // 새로를 담당하는 배열 생성
        - arr[0] = new int[2]; // 가로를 담당하는 배열 생성 
 
 ### for-each (Enhanced for 라고 부르기도 함)
 - for (int i = 0; i < arr.length; i++)
    System.out.println(arr[i] + "");
 - for (int e : arr)
    System.out.println(e + "");
        --> arr 이 반복의 대상이다. 
        --> 배열 arr의 모든요소 각각을 e라 할때
        --> e가 의미하는 각각의 요소 값을 출력하라. 
        --> e(배열 요소를 지칭하는 변수)는 배열 요소의 자료형과 일치해야한다. 
 - 아래와 같이 더 간단히 표기 가능하다. 
 - 만약 for-each문에서 e의 값을 변경시킨다면, 변경된 변수 e의 값은 for-each문 내에서만 의미를 지니므로,
    배열 요소의 값을 변경시키는 연산이 필요한 경우에는 for-each문 사용이 적절하지 않음. 
 - for-each문은 값의 참조만 가능하고 값의 변경은 불가능하다. --> X
    for-each문은 배열에 저장되어 있는 참조 값의 변경이 불가능하다. (인스턴스 배열은 인스턴스로 이뤄진 배열이 아닌 인스턴스의 참조변수로 이루어진 배열이기 때문.) --> 이게 더 정확한 말 
 
 ### main 메소드로의 데이터 전달
 - main 의 매개변수 선언 : String [] args --> String 인스턴스 배열의 참조값을 전달받기 위한 매개변수 선언
 
 ### main 으로의 데이터 전달방법
 class MainProgram
 {
    public static void main(string[] args)
    {
        for(String e : args)
            System.out.println(e);
    }
 }
    --> 그냥 실행시키면 아무것도 출력되지 않음
    --> java MainPrigram AAA BBB CCC
        AAA
        BBB
        CCC  가 출력된다. (문자열이 공백으로 구분됨은 알수 있음)
        String[] strArr = {'AAA', 'BBB','CCC'} 인 배열이 만들어지고 이것이 매개변수 String[] args 에 인자로 전달되는것이다. 
 
 # 자바 기본 공부 14 
 ## 클래스의 상속 1 : 상속의 기본 
 
 ### 상속은 재활용 + 알파
 - 재활용할 수 있다는 이유만으로 상속을 사용하면 안된다. (객체지향에서 언급하는 재활용은 클래스 단위의 재활용)
 - 이전에 개발해 놓은 클래스의 재활용을 보인 사례는 매우 드물다. 즉 상속은 재활용의 측면에서 바라보면 별로 매력적이지 않다. 
 - 재활용에 대한 이슈는 객체지향 패러다임에서 CBD패러다임으로 옮겨 갔다. (Component Based Development)
 - CBD 패러다임에서는 클래스단위의 재활용을 논하지 않는다. 패키지 단위 혹은 그보다 큰 규모에 대한 재활용을 논의한다. 
 
 ### 상속의 기본문법 이해 
 - 자바는 하나의 클래스만을 상속할 수 있다. C++은 다중상속을 지원한다. 
 - 상속은 기존에 정의된 클래스에 메소드와 변수를 추가하여 새로운 클래스를 정의하는 것 
 - 하위 클래스(=유도 클래스) : 상속 관계에 있어서 상속을 받은 클래스 
 - 상위 클래스(=기초 클래스) : 상속의 대상이 된 클래스 
 
 - 상위 클래스의 인스턴스 변수는 상위 클래스의 생성자 내에서 초기화가 되어야 하고, 
    단지 하위 클래스에서는 상위 클래스의 인스턴스 변수를 초기화하는데 필요한 데이터를 키워드 super를 통해서 전달만 하는 것이 합리적이다. 
 - super(1,4,6) --> 상위 클래스의 '생성자'를 호출하면서 1,4,6을 인자로 전달해라. 
 - 예제(BasicInheritence) 를 설명하자면)
    1. 메모리 공간에 인스턴스 할당 (디폴트 초기화)
    2. 생성자의 호출 (BusinessMan의 생성자)
    3. super문에 의해 상위클래스의 생성자 호출(Man 의 생성자) & 실행
    4. 하위 클래스의 생성자 실행 (상위클래스보다 먼저 호출되었지만 나중에 실행됨)
 
 - 하위 클래스의 생성자 내에서는 반드시 상위 클래스의 생성자가 호출되어야한다 
 - 만약 상위 클래스의 생성자를 호출할 수 없는 구조로 하위 클래스의 생성자가 정의된다면, 하위 클래스의 인스턴스 생성은 불가능하다. 
 - 그래서 임의의 클래스를 상속하는 하위 클래스를 정의할 때에는 상위 클래스에 대한 생성자 정보가 필요하다. 
    그래야 상위 클래스의 생성자 호출을 위한 super문을 구성할 수 있기 때문이다. 
    
 ### 상속과 접근제어 지시자 
 - protected 지시자 
    - protected & default 
        class AAa
        {   
            int num1;
            protected int num2;
        }
        class BBB extens AAa
        {
            BBB()
            {
                num1 = 10; // AAa클래스의 default 멤베에 접근
                num2 = 20; // AAa클래스의 protected 멤버에 접근 
            }
         }
         
        --> num1 & num2 둘다 가능 
            num1은 default여서 불가능 할 거라고 생각하지만 AAA클래스와 BBB클래스가 하나의 패키지로 묶이기 때문에 가능하다. 
        --> protected : 다른 패키지에 존재할지라도 상속관계에 놓이면 접근을 허용하는 접근제어 지시자. 
        
 - private 멤버도 상속은 된다. 하지만 간접적으로 접근해야한다. (안정성 확보를 위해서는 좋은 선택)
 
 ### static 변수(메소드)의 상속과 생성자의 상속에 대한 논의 
 - static 변수와 메소드는 생성되는 인스턴스마다 독립적으로 존재하는 멤버가 아니고, 생성되는 인스턴스가 함께 공유하는 변수 및 메소드이다. 
 - 상위 클래스에 정의되어 있는 static 변수에 하위 클래스도 그냥 접근이 가능한가..?
 - 상위 클래스에 정의되어 있는 static변수는 하위 클래스에서도 변수의 이름만으로 접근이 가능하다. 
 - 상속을 하고 있는 하위 클래스의 이름을 통해서도 상위 클래스의 static 변수 및 메소드에 접근이 가능하다. 
 
 - 자바의 생성자는 상속되지 않는다. 
    class AAA
    {
        int num;
        AAA(int n) { num = n;}
    }
    class BBB
    {
        BBB() {super(0);}
    }
    
    메인
    {
        BBB b1 = new BBB();  // 가능 
        BBB b2 = new BBB(1); // 불가능
    }
    --> 생성자가 상속된다면, BBB(int n) {num = n;} 형태로 BBB 클래스에게 상속됨을 뜻하는 것이다. but 그렇지 않으므로 생성자는 상속되지 않는다고 말하는것 
    
 # 자바 기본 공부 15
 ## 클래스의 상속 2 : 오버라이딩 
 
 ### 상속을 위한 관계 
 1. 상속을 위한 기본 조건인 IS-A 관계의 성립 
    - 상위 클래스와 하위 클래스에는 IS-A관계가 성립해야 한다. 만약 이 관계로 표현되지 않는다면 적절한 상속의 관계가 아닐 확률이 매우 높은 것 
    ex) 무선 전화기 is a 전화기
 2. HAS-A 관계도 상속의 조건은 되지만 복합관계로 이를 대신하는 것이 일반적이다. 
    - 하위 클래스는 상위 클래스가 지니고 있는 모든 것을 소유한다. 그래서 소유의 관계도 상속으로 표현 가능.
    ex) 경찰 has a 총
    - 그러나 이런 소유의 관계는 다른 방식으로도 얼마든지 표현 가능 
 - 상속은 IS-A 관계의 표현에 매우 적절하다. 그리고 경우에 따라서는 HAS-A 관계의 표현에도 사용될 수 있으나, 이는 프로그램의 변경에 많은 제약을 가져다 줄 수 있다. 
 
 ### 하위 클래스에서 메소드를 다시 정의한다면? --> 오버라이딩 
 - 메소드 오버라이딩 
    - 메소드의 이름, 반환형, 메개변수의 선언이 완전히 동일한 메소드를 재정의
    - 앞에서는 상위클래스의 생성자를 호출하는 용도로 super를 사용. 
    - super 사용하면 상위 클래스의 메소드, 그렇지 않으면 자기 클래스인 하위클래스의 메소드가 호출된다. 
    
 - '참조변수를 이용해서' 인스턴스의 오버라이딩된 메소드를 호출하면, 상위클래스가 아닌 하위클래스의 메소드가 호출된다. 
    - 상위 클래스에 정의된 메소드가 하위 클래스에 정의된 메소드에 의해 가려졌다고 이야기 할 수 있다.
    - 참조변수의 자료형에 상관없이(인스턴스 외부에서는)상위 클래스의 메소드는 호출이 불가능하며, 마지막으로 오버라이딩한 메소드만 호출된다. 
    
 - 상위 클래스의 참조변수로 인스턴스를 참조하면, 실제로 참조하는 인스턴스의 종류에 상관없이 speaker 클래스에 정의된 메소드만 호출 가능. (컴파일러가 그렇게 디자인 되어있음)
    (speaker sp = new baseenspeaker(); (baseenspeaker is a speaker))
 
 - XXX클래스의 참조변수는 XXX클래스의 인스턴스, 또는 XXX를 상속받는 하위 클래스의 인스턴스를 참조할 수 있다. 
    
 - 정리) 
    class AAA{}
    class BBB extends AAA {}
    class CCC extends BBB {}
    
    1) 모두 컴파일 가능 
        AAA ref1 = new BBB()
        AAA ref2 = new CCC()
        BBB ref3 = new CCC()
        
    2) 모두 컴파일 가능
        CCC ref1 = ... // 제대로 실행됨
        BBB ref2 = ref1
        AAA ref3 = ref1
        
    3) 
        AAA ref1 = new CCC()
        BBB ref2 = ref1
        CCC ref3 = ref1
        --> 컴파일러는 위에서 설명했듯이 ref1 이 참조하는 대상을 AAA클래스의 인스턴스라고 단순화시켜서 생각한다. 
        --> 그래서 아래 2개가 컴파일에러
     
     4) 고친것 
        AAA ref1 = new CCC()
        BBB ref2 = (CCC)ref1 --> 형변환해서 사용하면 됨. 그러나 매우 드물게 사용함.
        
 ### 참조변수의 인스턴스 참조와 instanceof 연산자 
 - 