#### 자바 기본서를 읽으면서 내가 몰랐던 부분 혹은 기록하고 싶은 부분만을 적어둠. 전부를 적어두는 것이 아님. 

# 자바 기본 공부 1
## 자바 프로그램의 실행 구조와 자바 가상머신 
__다른 프로그램들__ 은 운영체제가 직접 실행시키는 구조이지만 __자바 프로그램__ 은 자바 가상머신에 의해서 실행되는 구조이다.    
그 이유는 자바 프로그램을 운영체제에 상관없이 실행 시키기 위함이다. 운영체제에 따른 차이점을 자바 가상머신이 대신해주는 것이다. 그래서 가상머신은 운영체제에 따라 다르다.     

## 자바 컴파일러와 자바 바이트코드    
자바 컴파일러에 의해서 생성되는 코드를 __자바 바이트코드__ 라고 한다. 자바 컴파일러에 의해 생성되는 코드의 명령어 크기가 1바이트 이기 때문이다.     
과정을 살펴보면 자바의 소스코드가 __javac.exe__ 에 의해서 컴파일되고, 해당 파일이 __java.exe__ 에 의해서 가상머신을 기반으로 실행이 되는 것이다.      

## 프로그램의 골격과 구성 
클래스 이름이 Myclass이면 컴파일시 생성되는 파일의 이름은 Myclass.class이다. 

# 자바 기본 공부 2
## 변수
- 변수 : 데이터의 저장과 참조를 위해 할당된 메모리 공간    
- 자바에서 제공하는 기본 자료형 : boolean, char, byte, short, int, long, float, double     
- 실수의 표현에서 오차가 존재한다. 
    - 정밀도를 포기하고 표현의 범위를 넓히고자 했었다. 
    - float와 double을 선택할 때에도 정밀도를 기반으로 채택 
    - float는 6자리의 정밀도, double은 15자리의 정밀도를 가지고 있다. 
    - 큰 실수형을 표현하기 위해, e를 사용함. (e-3 은 10의 -3승을 의미한다.)
- 자바는 정수형 연산을 진행할 때, 모든 피연산자를 int형으로 변환하는 과정을 거친다. (int형이 정수연산을 가장 고속으로 처리하게끔 설계되어있기 때문 - int보다 작은 레벨의 자료형에서만, long은 int로 변환되지 않음)
- 변수의 이름 제한사항 
    - 변수의 이름은 숫자로 시작할 수 없음 
    - $와 _ 이외의 다른 특수문자 사용 불가. 
    - 키워드(자바의 문법을 구성하는 단어들)는 변수의 이름으로 사용 불가.    
- 문자 : 자바는 유니코드라는 표준을 근거로 문자를 표현한다. 그래서 자바에서 문자 하나를 변수에 저장하면 실제로는 해당 문자의 유니코드 값이 저장되는 것이다.     
    - 문자는 작은 따옴표로 표현이 된다. 

# 자바 기본 공부 3
## 상수와 형 변환 
- 상수 : 메모리 공간에 값이 저장은 되지만, 변수와 달리 저장된 값의 변경이 불가능하다. (변수와 달리 이름이 없기 때문에 메모리 공간에 접근 하지 못하므로)    
- 기본적으로 모든 정수형 상수는 int형으로 표현 및 저장한다. 그렇기 때문에 long num = 10000000 으로 하면 에러가 난다. int로 표현 저장하기 때문이다. 그래서 10000000L 로 표기해서 이정수를 long형으로 표현해달라고 해야한다. 
- 기본적으로 모든 실수형 상수는 double형으로 표현 및 저장한다. 이것도 마찬가지고 float num = 12.45로 하면 에러가 난다. 12.45F로 표현해야 한다. 
- 연산을 할때에는 자료형을 한개로 통일시켜 주어야 한다. --> 자바에서는 '자동 형 변환' 이라는 과정을 통해 CPU가 연산을 할 수 있도록 자료형을 하나로 일치시켜 준다. 
![자동형변환]()
- 가급적이면 자동으로 형 변환이 발생하는 위치에 명시적으로 형 변환이 됨을 표현하는 것이 좋다.    

# 자바 기본 공부 4 
## 연산자 
- 이항 연산자 : 피연산자가 두개인 연산자
- 연산자들의 우선순위로 인한 실수를 줄이기 위해 소괄호를 이용하는 경우가 많음. 
- 실수를 이용한 % 연산의 결과는 의미가 없으니 이런 연산문은 만들지 않도록 하는게 중요하다.    
- short circuit Evaluation (SCE = Lazy Evaluation): 가장 빠르게 연산을 진행하기 위한 계산 방식
    > SCE 코드를 통해 설명해둠. 
- 비트 연산자(&, |, ^, ~)의 피연산자는 반드시 정수여야 한다. 실수에 대해서는 비트연산이 불가능하다. 
- 비트연산자는 비트단위로 연산을 진행하고 그 연산의 결과를 묶어서 하나의 연산결과를 반환한다. 

# 자바 기본 공부 5 
## 살행흐름의 컨트롤 
- 조건문 
- 조건 연산자 : < true or false ? 숫자1 : 숫자2 > 로 표현한다. 
    - ? 왼편에 true가 등장하면 숫자1이 반환된다. 
- switch문 : switch, case, default, break로 구성됨. break가 없으면 모든 문장을 다 거치고 break가 있다면 거기서 switch문은 끝이 난다. 
- while 반복문 
    - 반복조건을 먼저 검사한 후에 반복영역의 실행여부를 결정한다. (검사결과가 true이면 반복영역이 실행됨)
    - 반복조건을 먼저 검사하기 때문에 반복영역이 한차례도 실행되지 않을 수 있다. 
    - 무한루프에 빠지지 않도록 조심해야한다. 
- do~while 반복문 
    - while 반복문과 다르게 반복영역이 한번은 무조건 실행됨. 
- for 반복문 
    - 반복변수를 초기화한후 반복조건이 만족되었는지 확인후 만족되었으면 반복영역을 실행함. 
    - 반복영역이 실행된 후 변수의 값이 작성된 것에 기반하여 변화한다. 
- break 
    - 가장 가까이에있는 반복문 한개를 빠져나가기 위한 용도로 사용됨. 
    - 상황에 따라 중첩된 반복문 모두를 나가야 하는 경우도 발생한다. 이럴때는 outerLoop : for(~,~,~) 로 반복문을 설정하고 , 빠져 나오고 싶은곳에 break outerLoop 를 써서 빠져나오면 된다. 
- continue
    - 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건검사 부분으로 이동시킴. 
 
# 자바 기본 공부 6
## 메소드와 변수의 스코프 

### 메소드 
- 자바 프로그램의 시작은 main이라는 이름의 메소드를 실행하는 데서부터 시작한다. 
- 프로그램 진행중, 메소드 호출문을 접하면, 해당 메소드의 실행이 완료된 다음에야 비로소 그 다음을 실행하게 된다. 
- 메소드가 정의되는 위치는 프로그램에 영향을 미치지 않음 
- 매개변수(parameter) : 메소드 이름 오른쪽 
    - 메소드 호출 시 전달되는 값의 저장을 위한 용도로 사용됨 --> 그래서 메소드 호출 시 전달되는 값의 자료형과 매개변수의 자료형은 일치해야함
- 반환 : 메소드 이름 왼쪽에 자료형은 반환값의 자료형 
    - void : 값을 반환하지 않는다. 
    - return 문을 실행하게 되면 메소드는 종료가 되고 메소드를 호출한 영역으로 값은 반환이 된다. 
    - 오직 한개의 값만 반환할 수 있다. 
    - return 이 가지는 2가지 의미 
        - 값의 반환 & 메소드의 종료
        - void에서도 return; 을 사용해 메소드 종료 가능 
        
        
### visibility 
- 지역변수 
    - 중괄호로 영역이 형성되면, 감싸이는 영역은 변수에 관한 별도의 스코프를 형성함. 
    - 변수는 자신이 속한 중괄호 내에서만(선언된 이후부터) 접근이 가능하다. --> 속한 영역이 다르면 이름이 동일할지라도 문제가 되지 않음
    - for문의 일부로 선언되는 변수, 메소드의 매개변수도 이어서 등장하는 중괄호 내에서만 접근이 가능하다. --> 그래서 매개변수에서 num이라는 변수를 사용했다면 그 중괄호 안에서는 이제 그 이름의 변수를 쓸수없다. 
    - 지역변수는 선언된 지역을 벗어나 버리면 메모리 공간에서 자동 소멸된다. 
    
### 메소드의 재귀호출 
- 아직 실행이 완료되지 않은 메소드를 어떻게 다시 호출하나?
    - 메모리에 저장된 메소드를 구성하는 명령문은 CPU로 이동해서 실행이 된다.
- 잘못된 재귀 메소드의 정의 --> 종료조건이 없다...!
    예시) InfRecul class 코드를 보면 cnt를 감소시켜 주기는 하지만 cnt--로 감소시켜 주어서 메소드가 호출이 된다음에야 감소된다. 
        그래서 이 코드는 무한히 돌게되는 것 --> --cnt로만 바꾸어도 해결가능 
        but 이렇게 한다고 해도, 재귀는 계속된다. 9-10행이 실행되지 않기 때문이다. 
        이것들의 위치를 8행과 바꾸면된다. 
        
    - 재귀의 연결 고리를 끊기 위한 조건검사의 위치가 적절해야한다.
    - 재귀의 연결 고리를 끊기 위한 조건검사가 true가 될 수 있도록 적절한 연산이 이루어져야 한다. 
 - 과도한 재귀의 사용은 메모리를 너무 많이 사용하게 하여 성능저하를 일으킬 수 있다. 
 
 # 자바 기본 공부 7
 ## 클래스와 인스턴스 
 
 ### 클래스의 정의와 인스턴스의 생성
 - 객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화시키는 형태의 프로그래밍. 
 - 객체를 이루는 것은 '데이터' & '기능'
 > 나는 과일장수에게 2000원을 주고 두개의 사과를 구매했다       

 위의 문장을 객체화하는 연습을 해보겠다 
 1. 객체 나누기 
    - 나, 과일장수, 사과 가 될 수 있다. 
    - 나, 과일장수만 객체로 인식하여 문제를 풀어보겠다
    
 2. 과일장수 객체를 이루는 것 
    - 과일장수는 과일을 판다. ---> 과일장수의 행위 <기능>
    - 과일장수는 사과 20개, 오렌지 10개를 가지고 있다. ---> 과일장수의 상태 <데이터>
    - 과일장수의 과일판매 수익은 50000원이다. 
    
    상태정보는 변수를 통해 표현되고, 행동은 메소드를 통해 표현된다. 
    
    - 변수 
        - 보유하고 있는 사과의 수 : int numOfApple;
        - 판매 수익 : int myMoney
    
    - 메소드 
        int saleApple(int money){       // 사과 구매액이 인자로 전달됨 
            int num = money / 1000;     // 사과 한개당 1000원이라고 가정 
            numOfApple -= num           // 팔린 사과의 수만큼 보유중인 사과수 줄이기 
            myMoney += money            // 판매 수익 발생 
            return num                  // 실제 구매가 발생한 사과의 수를 반환
        }
        
 3. 과일장수 클래스 정의 --> class라는 틀을 기반으로 객체 생성 
    - 객체를 생성하기 앞서 객체의 생성을 위한 틀(mold) 만들어야함. 틀 = class 
    - FruitSeller 라는 틀을 정의
        class FruitSeller
        {
            // 변수 선언 
            int numOfApple = 20;
            int myMoney = 0;
            
            // 메소드 정의 
            public int saleApple(int money)
            {
                int num = money / 1000;
                //동일클래스에 해당 변수가 있으므로 접근 가능 
                numOfApple -= num;
                myMoney += money;
                return num;
            }
        }
        
 4. 메소드 추가해보기 
    - 남은사과와 판매수익을 보여주는 메소드 추가 
                class FruitSeller
                {
                    // 사과가격
                    final int APPLE_PRICE = 1000;
                    // 변수 선언 
                    int numOfApple = 20;
                    int myMoney = 0;
                    
                    // 메소드 정의 
                    public int saleApple(int money)
                    {
                        int num = money / 1000;  ---> int num = money / APPLE_PRICE; 
                        //동일클래스에 해당 변수가 있으므로 접근 가능 
                        numOfApple -= num;
                        myMoney += money;
                        return num;
                    }
                    
                    // 추가된 메소드
                    public void showSaleResult()
                    {
                        System.out.println("남은사과: " + numOfApple);
                        System.out.println("판매수익: " + myMoney);
                    }
                        
                }      
    - final 변수
        - 변수가 상수화 된 것이기 때문에 final 상수라고도 부름 
        - 한번 값이 결정된 이 변수의 값은 변경이 불가능하다. 
        - 지역변수가 final 로 선언되면 딱 1번 초기화가 가능하다. 
                
 5. 나 클래스 정의
     - 변수 
         - 소유하고 있는 현금 : int myMoney
         - 소유하고 있는 사과의 수 : int numOfApple 
        
        class FruitBuyer
        {
            int myMoney = 5000;
            int numOfApple = 0;
            public void buyApple(FruitSeller seller, int money)
            {
                numOfApple+=seller.saleApple(money);
                moMoney-=money;
            }
            public void showButResult()
            {
                System.out.println("사과개수: " + numOfApple);
                System.out.println("현재잔액: " + myMoney);
            }
            
 6. 클래스 기반으로 객체 생성하기 
    - 객체 생성 방법 : ClassName name = new ClassName();
        - ClassName 객체를 생성하고 이를 name이라는 이름의 변수로 참조한다 라는 의미 (name : 참조변수)
        - new에 의해 객체 생성시 생성된 객체는 메모리에 저장되고, 저장된 메모리의 주소값(참조값)이 반환되어 참조변수에 저장된다.          
        - 그래서 참조변수에 의한 객체 접근이 가능한 것.
        - new 키워드 : 객체 생성을 명령하는 명령어
    - 이렇게 객제를 생성하는 행위를 가르켜 '인스턴스화' 라고 한다. 
    - 이렇게 생성이 된 객체를 '인스턴스' 라고 부른다. 
    - 클래스 & 객체 --> 메모리 관점에서 보면 매우 차이 있음 
        - 클래스에 존재하는 변수와 메소드는 메모리 공간에 할당된 형태로 존재하지 않음 --> 접근도 호출도 불가능한 상태 
        - 객체는 메모리 공간에 할당이 이루어짐 
    - 클래스를 정의하는 것은 자바에서 제공하는 기본 자료형 이외에 프로그래머가 새로운 이름의 자료형을 정의하는 것.
        
        - 예시)
            FruitSeller seller1 = new FruitSeller();
            instMethod(seller1);
            
            public void instMethod(FruitSeller seller2)
            {
                ....
            }
            --> 여기서 매개변수로 선언된 seller2에 seller1이 저장하고 잇는 객체의 참조값이 전달된다. 즉, 참조변수 seller1과 seller2가 하나의 객체를 동시에 참조하는 상황.
 
 - 하나의 객체가 다른 하나의 객체에게 메시지를 전달하는 방법은 메소드 호출을 기반으로 한다. 그래서 객체지향에서는 이러한 형태의 메소드 호출을 가리켜 '메시지 전달' 이라고 한다. 
 - 특정 개체로 초기화가 이뤄지지 않는다면 null로 초기화 할 수 있다. 

 ### 생성자 (Constructor)
 - 위에서 진행했던 과일장수 문제를 확장해서 과일장수가 2명 있다고 생각해보자 
 - 과일장수마다 사과의 가격이 다를 것이기 때문에 final APPLE_PRICE 로 정의한 부분이 문제가 된다. 
 - final로 사과가격을 지정하는 것이 아니라, 인스턴스를 생성하고 나서, 인스턴스 변수를 각각 초기화 하는 방식을 사용해야 한다. 
 
 - ch7의 Fruit2.java를 확인해보면 2가지 문제점이 있다는 것을 알수 있다. 
    1. 인스턴스를 생성하고 난 다음에 초기화하는 작업을 해야한다. 한번에 생성과 초기화가 되지 않고 두줄에 걸쳐 해야함
    2. 인스턴스 변수 APPLE_PRICE의 final 선언이 사라짐 (인스턴스 생성 이후 변경되지 않을 인스턴스 변수를 final로 선언함으로써 프로그램의 안전성을 향상시켰었음)
        초기화가 이루어지지 않은 final 변수는 한번의 초기화 기회를 가진다. 
        하지만 인스턴스 메소드는 두번 이상 호출될 수 있다. 
        그러므로 인스턴스 메소드 내에서 final 변수의 값을 초기화하는 행위가 허용되지 않는 것이다. 
        그러타면 딱한번만 호춛되는 메소드는? --> 생성자      
 
 - 생성자 
    - 생성자가 되기 위한 조건 
       1. 클래스의 이름과 동일한 이름의 메소드 
       2. 반환형이 선언되어 있지 않으면서, 반환하지 않는 메소드 
    - 생성자는 인스턴스 생성시 딱 한번 호출되는 메소드
    - Number num1 = new Number() --> new의 오른편에 있는 부분이 인스턴스의 생성과정에서 호출될 생성자를 명시하는 부분. 
        new Number --> Number의 인스턴스 생성 / Number() --> Number() 생성자 호출
    ---> "자바의 인스턴스 생성시에는 반드시 생성자가 호출되어야한다." 
    
    - 값을 전달받는 생성자 --> 이것이 있으므로 생성자를 이용해 인스턴스 변수의 초기화를 수월하게 할 수 있음을 깨닫게 됨 
    
 - Fruit2.java를 위에서 배운 값을 전달받는 생성자를 이용해 발전시켜보자 
 - 생성자가 없어도 인스턴스 생성이 가능한 이유 : 디폴트 생성자 (인자를 받지 않으면 하는 일이 아무것도없음)
 
 ### 자바의 이름 규칙 
 - 클래스의 이름 규칙
    - 'Camel Case'
        첫 문자는 대문자로 시작한다. 
        둘 이상의 단어가 묶여서 하나의 이름을 구성할 때, 새로 시작하는 단어는 대문자로 한다. 
        
 - 메소드와 변수의 이름 규칙 
    - 첫문자를 소문자로 시작하는 Camel Case방식을 사용한다. 
    
 - 상수의 이름 규칙 
    - 상수와 변수를 구분할 수 있도록 모든 문자를 대문자로 구성하는 것이 관례
    - 둘 이상의 단어가 연결되어야 하는 경우에는 _(언더바)를 사용한다. 
    
 # 자바 기본 공부 8 
 ## 클래스 패스와 패키지 
 
 ### 클래스 패스(class path)의 지정 
 - classpathtest 디렉토리 안에 java파일을 저장하고 컴파일 한후 
 - java파일의 일부인 class를 classpathtest의 서브클래스 mysubclass를 만들어 옮긴후 실행하면 문제가 발생한다. 
 - java.exe를 실행한 디렉토리에서만 가상머진에 올려질 클래스를 찾기 때문이다. 
 - 이때는 'java.exe를 실행시킨 현재 디렉토리의 서브 디렉토리인 mysubclass 디렉토리에서 클래스를 찾아보세요' 라는 메세지를 전달해야 한다. 
 - 위에서 말한 메세지는 '환경변수'라는 것을 이용해서 전달해야 한다. 
    - 환경변수 
        내가 만든 디렉토리인 classpathtest에 calc.exe가 존재 하지 않지만 classpathtest디렉토리에서 실행시켜 보면 실행이된다. --> 이것은 환경변수 path에 의해서 가능한 일이다. 
        환경변수 path에 저장된 정보가 무엇인지 확인해 보자 --> echo %path%로 확인가능 
        긴 문자열을 확인할 수 있다. 세미콜론에 의해서 데이터가 구분된다. 구분된 이 경로들은 모두 cmd에서 프로그램을 실행시킬 때, 해당 프로그램의 실행파일을 찾는 경로 정보로 활용됨
        환경변수라는 것은 path만 있는게 아님. 필요에 따라 추가할 수 있는 것이 환경변수. --> 자바에서는 클래스의 검색 경로를 지정할 수 있도록 classpath라는 환경변수를 정의하고 있다. 
        그래서 결론적으로 클래스의 경로정보를 classpath라는 환경변수에 추가함으로써 클래스의 검색경로를 확장할 수 있다. 
 - classpathtest 디렉토리에서 echo %classpath% 를 확인한다. 
 - set classpath=.; --> 이런식으로 classpath에 추가한다. 
 
 ### 패키지의 이해 
 - 기능만으로 클래스를 나누는 것은 제대로 된 클래스의 설계방식이 아니다. 
 - circle 문제를 이용해서 알아봄 
    - 한 팀은 둘레구하는 클래스 / 한 팀은 넓이 구하는 클래스 만들기로 함 
    - 만들어서 합치려고 보니 같은 class 이름을 사용함 
    - 우선, 컴파일부터 안되지만 디렉토리를 다르게 하여 컴파일한후 main에서 인스턴스를 생성할 때 제대로 생성되지 않을것이다. 
    
    --> 해결책 2가지 
        1. 컴파일 완료된 동일한 이름의 클래스 파일을 서로 다른 디렉토리에 저장한다. 
        2. 인스턴스 생성 시, 저장되어 있는 디렉토리 정보를 표시해서 클래스를 구분하게 한다. 
        
        orange.area.Circle. c1 = new orange.area.Circle();
        orange.perimeter.Circle. c1 = new orange.perimeter.Circle();
        --> orange : 패키지 (= 디렉토리) / area,perimeter : 서브패키지(= 서브디렉토리) 
        --> 패키지는 단순히 디렉토리를 나누는 개념이 아님. 패키지는 소스파일에 별도의 선언을 통해 만들어짐. 
        --> area 디렉토리에 존재하는 circle 클래스와 perimeter 디렉토리에 존재하는 circle 클래스를 각각 패키지 선언이라는 것을 통해 패키지의 개념으로 묶어주어야함 
        
 - 패키지와 클래스 패스의 관계
 
 - 패키지의 선언 
    - '이 클래스는 orange.area' 패키지에 묶겠다. 
        => package orange.area;
    - ch8 파일을 잘 확인해보면 패키지 구분이 되어 있는것을 확인할 수 있다. 
    
    
 # 자바 기본 공부 9
 ## 접근제어 지시자와 정보은닉, 그리고 캡슐화 
 
 ### 정보은닉 
 
 ### 객체지향 관점에서 빵점 
 - ch9 의 Fruit4를 보면 말도 안돼는 상황에 맞닥뜨리게 됨 
 - 그 이유 --> 외부에서 인스턴스 변수를 접근할 수 있기 때문 
 - 인스턴스 변수를 private를 사용하면됨 --> 프로그램의 안정성 높아짐  (인스턴스 변수는 정보은닉의 대상)
 
 ### 접근제어 지시자 
 - public, private, protected, 선언하지 않음 --> 4종류가 있음 
 - 인스턴스 변수는 정보은닉의 대상 but 이변수의 간접접근을 허용하기 위해 추가적인 메소드를 제공 = Access 메소드 
    Access 메소드 => setXXX() : 값을 변경하는 메소드 , getXXX() : 값을 반환하는 메소드 
 - 접근제어 지시자를 선언하지 않은 경우 (default)
 - 접근제어 지시자에 의한 접근 허용여부는 인스턴스가 아닌 클래스를 기준으로 따진다.
 - protected = default + 알파 
    --> default는 허용하지 않지만 protected는 허용하는 알파가 있다. 
    --> 상속의 개념이 빠지면 default와 다를바 없다. 
    --> 상속을 받는 클래스의 접근을 허용하는 지시자. 
    
 | 지시자 | 클래스 내부 | 동일 패키지 | 상속받은 클래스 | 이외의 영역
 | :--- | :---: | ---: | ---: | ---:|
 | private | O | X | X | X |
 | default | O | O | X | X |
 | protected | O | O | O | X |
 | public | O | O | O | O |
 
 ### public 클래스와 default 클래스 
 - public 클래스 
    - 하나의 소스파일에는 하나의 클래스만 public으로 선언할 수있다. 
    - public 클래스의 이름과 소스파일의 이름은 완전히 일치해야 한다. 
    --> 위와 같이 표기하는 이유 : 기능을 이해하는데 중요한 역할을 하는 public 클래스와 소스파일의 관계를 형성하기 위함.
 - 생성자도 private으로 선언할 수 있다. 이렇게 되면 클래스내부에서만 생성자 호출이 가능해진다. 이는 결국 외부에서의 인스턴스 생성을 허용하지 않겠다는 뜻이다. 
 - 디폴트 생성자 : 매개변수가 없는 생성자 
 
 #### 어떤 클래스를 public으로 선언할까
 - 필요한 상황에서는 반드시 클래스를 public으로 선언해야 한다. 
 
 #### 자바의 라이브러리는 클래스로 이루어져 있음
 - package orange.cal 의 calculator.java 참고
 - 일반적으로 라이브러리 형태의 클래스들을 정의한 때에는 최소한의 클래스만 public 으로 선언한다. 
 
 ### 캡슐화
 - 예를 들면 콘텍600 --> 재채기 콧물 코막힘 완화 --> 이것이 한개의 캡슐에 있음
                     --> 재채기 콧물 코막힘 이라는 각각의 캡슐이 3개가 있다면 캡슐화 아님 
 - 정보은닉과 캡슐화를 다른 개념이라고 인식하고 접근하자
 - 캡슐화를 한다고 해서 하나의  클래스로만 모든것을 구성해야하는 것은 아니다. 다른 클래스를 활용해도 됨. 
 
 # 자바 기본 공부 10 
 ## 클래스 변수와 클래스 메소드 
 
 ### static 변수 (클래스 변수)
 - 인스턴스 변수 : 인스턴스가 생성되었을 때 접근이 가능한 변수이기 때문에 인스턴스 변수 
 - 클래스 변수는 클래스가 정의만 되어도 접근이 가능한 변수이기 때문에 클래스 변수 
 
 - static으로 선언된 변수는 변수가 선언된 클래스의 모든 인스턴스가 공유하는 변수이다. 
    --> 인스턴스 변수가 인스턴스 별로 각각 존재하는 변수라면, static변수는 딱 한개만 존재해서 모든 인스턴스가 공유하는 형태의 변수
 - static 으로 선언된 변수는 메모리 공간에 하나만 존재하며, 어디서나 접근이 가능한 변수이다. 단 어디서나 접근이 가능하려면 static 변수도 public으로 선언되어야 한다. 
    
 - static변수는 클래스내부에서뿐만 아니라, 외부에서도 접근이 가능한 변수 
 - static변수는 인스턴스가 생성되기 이전에 별도의 메모리 공간에 할당되어 초기화까지 완료된다. 
    - 정확한 시점은 언제?
    - 자바는 컴파일이 완료되고 나서 하나의 실행파일이 만들어지는 것이 아닌, 여러개의 클래스 파일들만 생성됨. 
    - JVM은 실행되는 과정에 따라 필요한 클래스만 메모리 공간에 올려서 프로그램을 실행한다. (유연함, on-demand 실행 방식)
    --> 결론 ) static 변수가 초기화되는 시점은 JVM에 의해서 클래스가 메모리 공간에 올라가는 순간이다. 
    --> 그렇기 때문에 static 변수를 생성자를 통해서 초기화하면 안됨. 그러면 인스턴스가 생성될 때마다 새로운값이 대입되는 꼴.
    
 - static 변수의 활용
    - 인스턴스간에 데이터 공유가 필요한 상황에서는 static 변수를 선언한다. 
    - 클래스 내부 또는 외부에서 참조의 용도로만 선언된 변수는 static final 로 선언한다. 
    
 ### static 메소드 (클래스 메소드)
 - static 변수와 마찬가지로 인스턴스 이름을 이용한 호출, 클래스이름을 이용한 호출 모두 가능하다. 
 - 인스턴스를 생성하지 않아도 static 메소드를 호출 할 수 있다. 
 - 인스턴스 단위로 진행해야 할 일들이 존재하지 않는다면 (인스턴스 변수에 접근하지 않는다면), 이는 인스턴스 메소드가 아닌 static 메소드로 정의해야 하는 상황임. --> 그래야 인스턴스를 생성하는 일없이 간결히 코드 작성 가능 
 
 - static 메소드 내에서는 static 변수나 static 메소드가 아닌 인스턴스 변수나 인스턴스 메소드의 접근이 불가능하다. 
    class AAA
    {
        int num1;
        static int num2;
        static void changeNum()
        {
            num1++; // 문제 발생 
            num2++; // 문제 없음 
        }
    }
    
    --> 문제가 발생하는 이유 ) 만약 AAA인스턴스가 3개 만들어진다고 하면 각 인스턴스는 num1을 가지고 있는 상황
                                그러나 인스턴스 3개가 changeNum() 1개를 공유하고 있음. 
                                그래서 changeNum()에서 num1을 증가시키면 3개의 num1 중 어느것을 증가시켜야 하는지 불분명 
                                --> 그래서 접근이 불가능 한것 
    
 ### System.out.println & public static void main
 - System.out.println
    - System : java.lang 패키지에 묶여있는 클래스 이름 
    - println : 메소드
    - out : 클래스 이름을 통해 접근하니 static 변수이다. println이라는 메소드를 호출하는 걸 보니, static 변수이자 참조변수이다. 
    
 - public static void main
    - main 메소드는 어디든 존재할 수 있음(문법적으로 문제 없다.) (다만 실행을 시킬때 main메소드가 있는 클래스를 실행시켜 주어야 함)
    - main 메소드는 인스턴스의 생성과 상관없이 JVM에 의해 호출이 되므로 (핵심), 반드시 static으로 선언해야 한다. 
 
 - 메소드는 자신이 속해있는 클래스의 인스턴스 생성이 가능하다. (그래서 main메소드가 어디든 존재할 수 있는 것)
    class AAA
    {
        public static void makeAAA()
        {
            AAA a1 = new AAA();
        }
    }
    --> 가능 
    
 # 자바 기본 공부 11
 ## 메소드 오버로딩과 String 클래스 
 
 ### 메소드 오버로딩 
 - 매개변수의 형(type)이 다르거나 개수가 다르거나 
 - 반환형이 다른 것은 메소드 오버로딩이 성립되지 않음 
    ex) int isYour(int n){}  && boolean isYour(int n){} 
 - 자바의 생성자는 오버로딩을 지원한다. --> 생성자의 오버로딩으로 인해 하나의 클래스를 기반으로 다양한 형태의 인스턴스 생성이 가능해진다. 
 - 오버로딩 된 메소드는 대부분의 경우 상당히 유사하게 정의된다. 
    따라서 오버로딩 과정에서 중복되는 코드의 삽입이 부담스러움 
    그러나 메소드 내에서는 오버로딩된 다른 메소드의 호출이 가능하기 때문에, 이런 코드 중복문제 쉽게 해결 
 - 오버로딩된 생성자를 생각해보자 
    생성자의 경우, 인스턴스의 생성과정에서만자동으로 호출될 뿐 그 이외의 영역에서는 명시적으로 호출할 수 있는 대상이 아님. 
    그래서, 생성자에 한해서 (only 생성자) 오버로딩 된 다른 생성자의 호출을 허용한다. --> this 라는 키워드 이용 (예제 확인)
        * this 의 사용 형태 3가지 
            1) 클래스의 속성과 생성자/메소드의 매개변수의 이름이 같은경우 (클래스 속성을 사용할때 this 키워드를 붙여줌)
            2) 클래스에 오버로딩된 다른 생성자 호출 
            3) 객체 자신의 참조값을 전달하고 싶을 때 
            
            // class SimpleAdder 안의 메소드
            public SimpleAdder add(int num)
            {
                this.num += num;
                //자기 자신을 참조할 수 있는 참조 값이 반환
                return this;
            } 
            --> 이 메소드의 반환형이 SimpleAdder. 
 
 ### String 클래스 
 - 자바는 문자열도 인스턴스로 처리하기 위해서 String이라는 이름의 클래스를 정의하고 있음. 
 - 지금까지의 인스턴스는 new를 이용하여 생성했지만, String의 인스턴스는 큰따옴표만으로 생성 가능. 
    ex) String str = "String instance";
    ex) System.out.println("Hello world") --> 여기서도 String인스턴스가 생성되어 메소드의 인자로 전달되는 것이다. 
                                              println 메소드의 매개변수형이 String인것. 
 - str.length() --> length라는 메소드를 호출함 --> str이 인스턴스임을 증명하는 증거. 
   "해해해".length(); == (new AAA()).bbb(); 
 - String 클래스의 인스턴스는 상수의 성격을 지니다. --> String의 인스턴스에 저장된 문자열데이터의 변경이 불가능하기 때문.
 - String인스턴스는 배열을 기반으로 큰 타옴표로 명시된 문자열 데이터를 저장하게 된다. 
 - 자바는 인스턴스 생성의 수를 줄이기 위해서 동일한 문자열 데이터로 구성되는 String 인스턴스의 생성을 하나로 제한한다. 
    그리고 이를 통한 문제의 발생을 막기 위해서 String 인스턴스의 데이터 변경은 허용하지 않고 있다. 
 
 ### API Document의 참조를 통한 String 클래스의 인스턴스 메소드 관찰 
 - 메소드들에 대해 반드시 API문서상에서 다시 한번 확인하는 습관을 들려라. (java.sun.com)
 - 문자열 복사 )
    String str1 = "LEMON";
    String str2 = "LEMON";
    String Str3 = new String(Str2)
    --> str1 & str2 는 같은 인스턴스를 참조한다. 
    --> 별도의 인스턴스에 저장하기 위해 3번째줄과 같이 해줌 , str2와 str3은 다른 인스턴스를 참조한다(같은 문자열임에도 불구하고)
 - 문자열의 + 연산 
    - String str4 = "Lemon" + 'A' --> String.ValueOf('A')  (매개변수를 문자열로 만들어주는 메소드) 가 호출된다. 그리고 문자열2개를 결합하는 concat() 메소드가 호출되는것.
    - + 연산이 많으면 그 개수만큼 인스턴스가 만들어진다? No. 그렇게 되면 너무 부담 커짐 --> 자바 컴파일러는 문자열결합의최적화를 수행해서 아무리 많은 + 연산이더라도 추가적 인스턴스 생성은 2개로 제한된다. 
    ex) String str5 = 1+"Lemon" + 3;
        --> String str5 = new StringBuilder().append(1).append("Lemon").append(3).toString();
        --> new StringBuilder() : 이부분에 의해 인스턴스 하나가 생성됨.
            그리고 append() 메소드가 호출됨. 
            new StringBuilder().append(1).append("Lemon").append(2) : 여기까지하면 1Lemon3 을 버퍼에 저장하는 StringBuilder 인스턴스가 완성되는것 
            우리는 String 인스턴스를 원함 그래서 toString() 로 String 인스턴스 생성. 
            그래서 총 2개의 인스턴스가 생성되는 것.
        
 ### StringBuilder & StringBuffer 클래스 
 - StringBuilder 와 StringBuffer 는 변경이 가능한 문자열의 표현을 위한 클래스. 
 - String으로 된 문자열을 변경할 일이 있다면, StringBuilder strb = new StringBuilder(string으로된 문자열) --> 이런식으로 하여 StringBuilder에 복사한 후 변경하면됨.
 
 - StringBuilder
    - 이것은 문자열의 저장, 변경을 위한 메모리 공간(버퍼)을 내부에 지님.
    - 주요 메소드 ) append, insert
        * append (인스턴스 자신의 참조값(this)을 반환함)
            // class SimpleAdder 안의 메소드
            public SimpleAdder add(int num)
            {
                this.num += num;
                //자기 자신을 참조할 수 있는 참조 값이 반환
                return this;
            } 
            --> 이 메소드의 반환형이 SimpleAdder.   
            --> main 메소드에서 
                SimpleAdder adder = new SimpleAdder();
                adder.add(1).add(3).add(5).showResult();
                --> adder.add 메소드의 반환값이 adder이기 때문에 반환되는 참조값을 통한 메소드의 호출이 가능한것이다. 
    - 이 메모리공간의 크기는 자동조절됨
        - public StringBuilder() //16개의 문자 저장 버퍼 생성
        - public StringBuilder(int capacity) // capacity 개의 문자 저장 버퍼 생성 
    
        - 버퍼크기 확장하는 작업은 많은 연산이 요구됨. 그래서 가급적이면 필요로하는 버퍼의 크기를 미리 할당하는 것이 성능에 도움됨. 
 
 - StringBuffer
    - StringBuilder와의 차이점 --> StringBuffer는 쓰레드에 안전하지만, StringBuilder는 쓰레드에 안전하지 못하다. 
    
 # 자바 기본 공부 12 
 ## 콘솔 입력과 출력 
 
 ### 콘솔 출력 
 - System.out.println 와 System.out.print
    - 위 두개의 메소드에서 인자로 문자열이 아닌 인스턴스의 참조값이 전달되면, 해당 인스턴스의 toString 메소드를 호출하여, 이때 반환되는 문자열을 출력한다.
        class Friend{
            ...
            // 여기에서 문자열이 반환된다고 하였는데 실제 반환되는 것은 return 이후에 나온 것("제이름은 " + myName + "입니다.")에 의해서 생성된 인스턴스의 참조값이 반환되는 것이다. 
            public String toString(){
                return "제이름은 " + myName + "입니다.";
            }
        }
        Friend fri1 = new Friend("김보원");
        System.out.println(fri1);
 - 이스케이프 시퀀스 
    - ＼ 로 시작한다. 
    - ＼n ＼t ＼"(큰따옴표) ＼＼(역슬래쉬)
 - System.out.printf
    - %d(10진수 정수) %f(실수) %c(문자 'A') %s(문자열) %e(e표기법) %g(출력대상에 따라 %e,%f로 출력)
    - e 표기법 : 1.7 X 10의 -10승 --> 1.7e-10 
 ### 콘솔 입력
 - Scanner class 
    - java.util 패키지에서 제공하는 클래스 
    - Scanner는 키보드의 입력을 위해서만 디자인된 클래스가 아니다. 
         Scanner(File source) , Scanner(InputStream source), Scanner(Readable source), Scanner(String source)와 같이 여러개의 생성자가 있음 
    - Scanner는 모든 공백(스페이스 바, 탭, 엔터 의 입력)이 데이터를 구분하는 기준이 된다. 
 
 * 매개변수는 메소드를 나오면 소멸된다. 
 
 # 자바 기본 공부 13
 ## 배열 (Array)
 
 ### 배열이라는 존재가 필요한 이유 
 - 배열의 선언은 둘 이상의 변수 선언에 편의를 제공한다. 
 - 배열로 선언된 변수들에는 반복문을 이용해서 동ㅇㄹ한 코드 패턴을 적용할 수 있다.
 
 ### 1차원 배열의 이해와 활용 
 - 문자열이 인스턴스 이듯, 배열도 인스턴스이다. 
 - 배열의 참조변수 선언
    int [] ref; --> int형 변수로 이루어진 배열,의 참조변수 ref 
 - 배열은 기본 자료형으로만 선언해야 하는 것 아님. 클래스 기반으로도 생성 가능 
    FruitSeller [] arr1 = new FruitSeller[5]; 
        --> 배열 안에는 다섯개의 FruitSeller클래스형 변수가 존재한다. & 인스턴스 변수(length)도 존재한다. 
 - 주의 ) 인스턴스 배열은 '참조변수의 배열'. 인스턴스로 이루어진 배열이 아니라, 인스턴스의 참조값을 저장할 수 있는 참조변수로 이루어진 배열. 
 - 선언과 동시에 초기화 가능 
    - int[] arr = new int[3] {1,2,3}; --> 초기화할 값들을 중괄호안에 나열하면 된다. 
    - int[] arr = {1,2,3}; --> 이렇게 줄여쓰는것이 관례
 
 ### 다차원 배열의 이해와 활용 
 - 2차원 배열 
    - int[][] arr2 = new int[5][8];
        --> 5 : 세로의 길이 / 8 : 가로의 길이 
    - 인스턴스 변수 (length) 사용 
        --> arr2.length; 배열의 세로 길이 
        --> arr2[1].length; 배열의 각행 길이로 사용 
    - 선언과 동시에 초기화 
        - int[][] arr = {
            {1,2},
            {5,6,7},
            {9,10,11,12}
          };
        --> 이런식으로 하게 되면, 1행의 길이는 2, 2행의 길이는 3, 3행의 길이는 4인 행의 길이가 일정하지 않는 2차원 배열이 생성된다. --> Ragged Array 라고 함.
    - 행과 열을 분리하여 선언하는 것 가능 
        - int [][] arr = new int[3][]; // 새로를 담당하는 배열 생성
        - arr[0] = new int[2]; // 가로를 담당하는 배열 생성 
 
 ### for-each (Enhanced for 라고 부르기도 함)
 - for (int i = 0; i < arr.length; i++)
    System.out.println(arr[i] + "");
 - for (int e : arr)
    System.out.println(e + "");
        --> arr 이 반복의 대상이다. 
        --> 배열 arr의 모든요소 각각을 e라 할때
        --> e가 의미하는 각각의 요소 값을 출력하라. 
        --> e(배열 요소를 지칭하는 변수)는 배열 요소의 자료형과 일치해야한다. 
 - 아래와 같이 더 간단히 표기 가능하다. 
 - 만약 for-each문에서 e의 값을 변경시킨다면, 변경된 변수 e의 값은 for-each문 내에서만 의미를 지니므로,
    배열 요소의 값을 변경시키는 연산이 필요한 경우에는 for-each문 사용이 적절하지 않음. 
 - for-each문은 값의 참조만 가능하고 값의 변경은 불가능하다. --> X
    for-each문은 배열에 저장되어 있는 참조 값의 변경이 불가능하다. (인스턴스 배열은 인스턴스로 이뤄진 배열이 아닌 인스턴스의 참조변수로 이루어진 배열이기 때문.) --> 이게 더 정확한 말 
 
 ### main 메소드로의 데이터 전달
 - main 의 매개변수 선언 : String [] args --> String 인스턴스 배열의 참조값을 전달받기 위한 매개변수 선언
 
 ### main 으로의 데이터 전달방법
 class MainProgram
 {
    public static void main(string[] args)
    {
        for(String e : args)
            System.out.println(e);
    }
 }
    --> 그냥 실행시키면 아무것도 출력되지 않음
    --> java MainPrigram AAA BBB CCC
        AAA
        BBB
        CCC  가 출력된다. (문자열이 공백으로 구분됨은 알수 있음)
        String[] strArr = {'AAA', 'BBB','CCC'} 인 배열이 만들어지고 이것이 매개변수 String[] args 에 인자로 전달되는것이다. 
 
 # 자바 기본 공부 14 
 ## 클래스의 상속 1 : 상속의 기본 
 
 ### 상속은 재활용 + 알파
 - 재활용할 수 있다는 이유만으로 상속을 사용하면 안된다. (객체지향에서 언급하는 재활용은 클래스 단위의 재활용)
 - 이전에 개발해 놓은 클래스의 재활용을 보인 사례는 매우 드물다. 즉 상속은 재활용의 측면에서 바라보면 별로 매력적이지 않다. 
 - 재활용에 대한 이슈는 객체지향 패러다임에서 CBD패러다임으로 옮겨 갔다. (Component Based Development)
 - CBD 패러다임에서는 클래스단위의 재활용을 논하지 않는다. 패키지 단위 혹은 그보다 큰 규모에 대한 재활용을 논의한다. 
 
 ### 상속의 기본문법 이해 
 - 자바는 하나의 클래스만을 상속할 수 있다. C++은 다중상속을 지원한다. 
 - 상속은 기존에 정의된 클래스에 메소드와 변수를 추가하여 새로운 클래스를 정의하는 것 
 - 하위 클래스(=유도 클래스) : 상속 관계에 있어서 상속을 받은 클래스 
 - 상위 클래스(=기초 클래스) : 상속의 대상이 된 클래스 
 
 - 상위 클래스의 인스턴스 변수는 상위 클래스의 생성자 내에서 초기화가 되어야 하고, 
    단지 하위 클래스에서는 상위 클래스의 인스턴스 변수를 초기화하는데 필요한 데이터를 키워드 super를 통해서 전달만 하는 것이 합리적이다. 
 - super(1,4,6) --> 상위 클래스의 '생성자'를 호출하면서 1,4,6을 인자로 전달해라. 
 - 예제(BasicInheritence) 를 설명하자면)
    1. 메모리 공간에 인스턴스 할당 (디폴트 초기화)
    2. 생성자의 호출 (BusinessMan의 생성자)
    3. super문에 의해 상위클래스의 생성자 호출(Man 의 생성자) & 실행
    4. 하위 클래스의 생성자 실행 (상위클래스보다 먼저 호출되었지만 나중에 실행됨)
 
 - 하위 클래스의 생성자 내에서는 반드시 상위 클래스의 생성자가 호출되어야한다 
 - 만약 상위 클래스의 생성자를 호출할 수 없는 구조로 하위 클래스의 생성자가 정의된다면, 하위 클래스의 인스턴스 생성은 불가능하다. 
 - 그래서 임의의 클래스를 상속하는 하위 클래스를 정의할 때에는 상위 클래스에 대한 생성자 정보가 필요하다. 
    그래야 상위 클래스의 생성자 호출을 위한 super문을 구성할 수 있기 때문이다. 
    
 ### 상속과 접근제어 지시자 
 - protected 지시자 
    - protected & default 
        class AAa
        {   
            int num1;
            protected int num2;
        }
        class BBB extens AAa
        {
            BBB()
            {
                num1 = 10; // AAa클래스의 default 멤베에 접근
                num2 = 20; // AAa클래스의 protected 멤버에 접근 
            }
         }
         
        --> num1 & num2 둘다 가능 
            num1은 default여서 불가능 할 거라고 생각하지만 AAA클래스와 BBB클래스가 하나의 패키지로 묶이기 때문에 가능하다. 
        --> protected : 다른 패키지에 존재할지라도 상속관계에 놓이면 접근을 허용하는 접근제어 지시자. 
        
 - private 멤버도 상속은 된다. 하지만 간접적으로 접근해야한다. (안정성 확보를 위해서는 좋은 선택)
 
 ### static 변수(메소드)의 상속과 생성자의 상속에 대한 논의 
 - static 변수와 메소드는 생성되는 인스턴스마다 독립적으로 존재하는 멤버가 아니고, 생성되는 인스턴스가 함께 공유하는 변수 및 메소드이다. 
 - 상위 클래스에 정의되어 있는 static 변수에 하위 클래스도 그냥 접근이 가능한가..?
 - 상위 클래스에 정의되어 있는 static변수는 하위 클래스에서도 변수의 이름만으로 접근이 가능하다. 
 - 상속을 하고 있는 하위 클래스의 이름을 통해서도 상위 클래스의 static 변수 및 메소드에 접근이 가능하다. 
 
 - 자바의 생성자는 상속되지 않는다. 
    class AAA
    {
        int num;
        AAA(int n) { num = n;}
    }
    class BBB
    {
        BBB() {super(0);}
    }
    
    메인
    {
        BBB b1 = new BBB();  // 가능 
        BBB b2 = new BBB(1); // 불가능
    }
    --> 생성자가 상속된다면, BBB(int n) {num = n;} 형태로 BBB 클래스에게 상속됨을 뜻하는 것이다. but 그렇지 않으므로 생성자는 상속되지 않는다고 말하는것 
    
 # 자바 기본 공부 15
 ## 클래스의 상속 2 : 오버라이딩 
 
 ### 상속을 위한 관계 
 1. 상속을 위한 기본 조건인 IS-A 관계의 성립 
    - 상위 클래스와 하위 클래스에는 IS-A관계가 성립해야 한다. 만약 이 관계로 표현되지 않는다면 적절한 상속의 관계가 아닐 확률이 매우 높은 것 
    ex) 무선 전화기 is a 전화기
 2. HAS-A 관계도 상속의 조건은 되지만 복합관계로 이를 대신하는 것이 일반적이다. 
    - 하위 클래스는 상위 클래스가 지니고 있는 모든 것을 소유한다. 그래서 소유의 관계도 상속으로 표현 가능.
    ex) 경찰 has a 총
    - 그러나 이런 소유의 관계는 다른 방식으로도 얼마든지 표현 가능 
 - 상속은 IS-A 관계의 표현에 매우 적절하다. 그리고 경우에 따라서는 HAS-A 관계의 표현에도 사용될 수 있으나, 이는 프로그램의 변경에 많은 제약을 가져다 줄 수 있다. 
 
 ### 하위 클래스에서 메소드를 다시 정의한다면? --> 오버라이딩 
 - 메소드 오버라이딩 
    - 메소드의 이름, 반환형, 메개변수의 선언이 완전히 동일한 메소드를 재정의
    - 앞에서는 상위클래스의 생성자를 호출하는 용도로 super를 사용. 
    - super 사용하면 상위 클래스의 메소드, 그렇지 않으면 자기 클래스인 하위클래스의 메소드가 호출된다. 
    
 - '참조변수를 이용해서' 인스턴스의 오버라이딩된 메소드를 호출하면, 상위클래스가 아닌 하위클래스의 메소드가 호출된다. 
    - 상위 클래스에 정의된 메소드가 하위 클래스에 정의된 메소드에 의해 가려졌다고 이야기 할 수 있다.
    - 참조변수의 자료형에 상관없이(인스턴스 외부에서는)상위 클래스의 메소드는 호출이 불가능하며, 마지막으로 오버라이딩한 메소드만 호출된다. 
    
 - 상위 클래스의 참조변수로 인스턴스를 참조하면, 실제로 참조하는 인스턴스의 종류에 상관없이 speaker 클래스에 정의된 메소드만 호출 가능. (컴파일러가 그렇게 디자인 되어있음)
    (speaker sp = new baseenspeaker(); (baseenspeaker is a speaker))
 
 - XXX클래스의 참조변수는 XXX클래스의 인스턴스, 또는 XXX를 상속받는 하위 클래스의 인스턴스를 참조할 수 있다. 
    
 - 정리) 
    class AAA{}
    class BBB extends AAA {}
    class CCC extends BBB {}
    
    1) 모두 컴파일 가능 
        AAA ref1 = new BBB()
        AAA ref2 = new CCC()
        BBB ref3 = new CCC()
        
    2) 모두 컴파일 가능
        CCC ref1 = ... // 제대로 실행됨
        BBB ref2 = ref1
        AAA ref3 = ref1
        
    3) 
        AAA ref1 = new CCC()
        BBB ref2 = ref1
        CCC ref3 = ref1
        --> 컴파일러는 위에서 설명했듯이 ref1 이 참조하는 대상을 AAA클래스의 인스턴스라고 단순화시켜서 생각한다. 
        --> 그래서 아래 2개가 컴파일에러
     
     4) 고친것 
        AAA ref1 = new CCC()
        BBB ref2 = (CCC)ref1 --> 형변환해서 사용하면 됨. 그러나 매우 드물게 사용함.
        
 ### 참조변수의 인스턴스 참조와 instanceof 연산자 
 - 인스턴스의 자료형에 따라서 호출할 메소드를 다르게 하려면 instanceof 를 사용해라. (예제 참고)
 - instanceof는 참조변수가 참조하고 있는 인스턴스의 실제 자료형을 묻는 연산자가 아니라, 상속관계를 바탕으로 형변환이 가능한지를 묻는 연산자. 
        그 결과로 true/false를 반환한다. 
 - instanceOf 를 사용하지 않고 메소드오버라이딩을 사용하는 방법도 있을 수 있음. (예제 참고)
 
 # 자바 기본 공부 16
 ## 클래스의 상속 3 : 상속의 목적 
 
 ### 개인정보 관리 프로그램
 - 상속의 관계는 클래스를 처음 설계하는 과정에서 결정된다. (대부분의 상속은 매우 계획적으로 이루어진다)
 
 - 지금까지의 클래스들은 데이터적 성격이 강한 클래스였다. but 목적, 제공하는 기능에 맞게 프로그램의 흐름을 컨트롤해주는 클래스가 최소한 한개는 필요하다. 
 - 객체지향에서는 이런 클래스들을 'Control 클래스', 'Manage 클래스'라고 한다. 
 
 - FriendInfoHandler 클래스는 상속을 통해 연관된 HighFriend, UnivFriend, 클래스(일련의 클래스)에 대해 동일한 방식으로 배열에 저장 및 메소드 호출(공통적인 규약)을 할 수 있습니다. 
  --> 상속을 통해 연관된 일련의 클래스에 대한 공통적인 규약을 정의할 수 있습니다. 
  
 ### 모든 클래스가 상속하는 Object클래스
 - 우리가 정의하는 모든 클래스의 인스턴스가 System.out.println의 인자로 전달될 수 있으며, 인자로 전달된 인스턴스의 toString메소드가 반환하는 문자열이 출력됨을 알고있다. 
    --> public void println(Object x) 
    --> 위와 같이 오버로딩되어 있는 메소드 이기 때문에 어떤 클래스의 인스턴스이건 인자로 전달될 수 있는것이다. 
    
 - 모든 클래스는 Object 클래스를 상속한다.
    --> 클래스를 상속할 때 다른 어떤 클래스를 상속하지 않으면, 해당 클래스는 java.lang 패키지에 묶여있는 Object클래스를 상속하게 된다. 
    --> 모든 자바 인스턴스에 공통된 기준을 적용하기 위해서 object클래스를 상속하도록 한 것이다. 
    
 - 기본적으로 오버라이딩 해 두면 좋은 toString 메소드 
 
 ### final 클래스와 final 메소드 
 - 클래스의 final 
    - 상수를 선언할때 키워드 final 이 사용됨을 알고 있다. 
    - 클래스 정의에 final 을 추가하면, '이 클래스를 상속하는 것을 허용하지 않겠다.' 는 의미 
    - 대표적인 final 클래스는 String 클래스 --> 그래서 String클래스를 상속해서 나만의 문자열 클래스를 정의하는 것은 불가능 
 
 - final 메소드 
    - 메소드가 final로 선언되면, '이 메소드의 오버라이딩을 허용하지 않겠다.' 는 의미 
    - 대표적인 메소드는 Object클래스의 wait, notify, notifyall 메소드가 있다. 
      
 # 자바 기본 공부 17
 ## abstract와 interface 그리고 inner class 
 
 ### abstract 클래스 
 - 예제에서 실행한 Friend 클래스의 인스턴스는 생성하면 안되는, 상속의 관계를 형성하기 위한 클래스 였음 
 - 하지만 실수로 인스턴스를 생성하더라고 컴파일 오류 없음 
 - 오류를 발생하게 하도록 하는 것이 abstract class 이다
 - abstract 클래스는 완전하지 않는 클래스를 의미함
 
 - ch16의 예시를 보면 Friend는 인스턴스를 생성하면 안되는 클래스이미로 abstract로 선언해주면 더 좋다. 
 - 그 안의 showBasicInfo() 메소드도 안은 비어있어 완전하지 않다. --> 추상메소드 (abstract 메소드)라고 한다. 명시적으로 나타내기 위해 abstract키워드를 붙인다. 
 - abstract 메소드가 정의되어 있는 클래스는 인스턴스 생성이 불가능하기 때문에 이때는 반드시 클래스에 abstract 키워드가 필요하다. 
 - abstract 클래스를 상속하는 하위 클래스에서 반드시 해야할일 
    abstract class AAA{
        void methodOne(){}
        abstract methodTwo();
    }
    
    class BBB extends AAA{
        void methodTwo(){}
    }
    
    --> 컴파일 오류생김 
        BBB클래스는 AAA클래스를 상속하고 있는데, BBB클래스에서 methodTwo 메소드를 오버라이딩하지 않고 있다. 
        그래서 abstract 상태의 methodTwo 메소드가 그대로 상속된다. 
        즉, BBB클래스는 상속으로 인해 abstract 메소드를 멤버로 포함한 꼴인것. 
        따라서, BBB도 absract로 선언하던지, methodTwo메소드를 오버라이딩해주어야 컴파일 가능 
        
 ### interface 
 문제)
 - 이름과 주민등록번호를 저장하는 기능의 클래스가 필요하다. 
 - 이 클래스에는 주민등록 번호를 기반으로 사람의 이름을 찾는 기능이 포함되어야한다.
 - 주민등록번호와 이름의 저장 -> void addPersonalInfo(String name, String perNum)
 - 주민등록번호를 이용한 검색 -> String searchName(String perNum)
 --> 위와 같이 의뢰하면 원하는 결과가 안나올수도 있다. 그래서 클래스를 하나 정의해서 이 클래스를 상속해서 기능을 완성시켜 달라고 요구한다. 
    abstract class PersonalNumberStorage{
        public abstract void addPersonalInfo(String name, String perNum);
        public abstract String searchName(String perNum);
    }
    - 위 클래스를 기반으로 main 프로그램을 작성하면 main 프로그램 안의 모든 메소드 호출이 PersonalNumberStorage 클래스 기반으로 진행되고 있다. 
    - PersonalNumberStorage 클래스는 의뢰한 결과물과 main 사이의 교량 역할을 한다고 볼수있다. 
 
 - 위에서 정의한 클래스는 abstract 메소드로만 이루어져 있는데, 이러한 경우에는 interface 의 정의로 abstract 클래스의 정의를 대체할 수 있다. 
    interface class PersonalNumberStorage{
          public void addPersonalInfo(String name, String perNum);
          public String searchName(String perNum);
    }
 
 - 인터페이스가 가지는 특징 
    - 인터페이스 내에 존재하는 변수는 무조건 public static final로 선언한다. 
    - 인터페이스 내에 존재하는 메소드는 무조건 public abstract로 선언된다. 
    + 인터페이스 역시 참조변수의 선언도 가능하고 특히, 메소드의 오버라이딩도 그대로 적용된다
    - 메소드를 오버라이딩 하는 과정에서 접근의 허용범위를 좁히는 방식으로는 접근제어 지시자를 변경할 수 없다. / 허용범위를 넓히는 방식으로만 변경이 가능함 (일반적인 오버라이딩 원칙)
    - 인터페이스는 public으로 선언하는 것이 일반적이다.
    - 두개의 인터페이스가 정의되어 있을때, 클래스는 두개의 인터페이스 안에 있는 메소드를 동시에 구현할 수 있다. 
        class ourclass implements my, your{.....(메소드 구현)}
    - 인터페이스 간에도 상속이 가능하다. (이때는 extends를 사용한다.)
 
 - interface기반의 상수표현 
    public class week{
        public static final int MON = 1;
        public static final int TUE = 2;
        public static final int WED = 3;
        public static final int THU = 4;
    } 
    
    public interface week{
        int MON = 1, TUE = 2, WED = 3, THU = 4;
    }
    --> 아래와 같이 interface로 나타내면 간단해짐 --> 이것이 바로 자바에서 사용하는 다수의 상수선언방식이다. 
    
 - 또다른 기능 
    - InterfaceMark.java를 확인해보면 
        UpperCasePrintable 인터페이스를 구현하는 클래스의 인스턴스 --> ClassPrinter.print 메소드의 인자로 전달되면 --> 대문자로 출력 
        UpperCasePrintable 인터페이스를 구현하지않는 클래스의 인스턴스 --> ClassPrinter.print 메소드의 인자로 전달되면 --> 소문자로 출력 
        --> 이렇게 UpperCasePrintable 인터페이스는 '다른 클래스와의 구별을 위한 특별한 표시의 목적으로 사용되었다.'
 
 - 인터페이스를 통한 다중상속의 효과 
    - 하나의 클래스가 둘 이상의 클래스를 동시에 상속하는 것을 의미함 
    예시) IPTV 
        - 인터넷으로부터 방송데이터를 받아 TV에 출력한다. --> IPTV는 일종의 TV다. 
        - 하드디스크, CPU, 메인메모리가 존재한다. --> IPTV는 일종의 Computer이다.
        --> IPTV는 TV이면서 Computer인것 
        --> BUT, 자바는 다중상속을 지원하지 않음 (why? 득보다 실이 많다고 판단되기 때문에)
            class Employee{public void work();}
            class Engineer extends Employee{}
            class Marketer extends Employee{}
            class Company extends Marketer, Engineer{}
            --> 이렇게 되면 다이아몬드 상속 구조를 지니게됨 (UML로 나타내보면 다이아몬드 모양)
            이러면 호출할 메소드의 선택이 모호해지는 경우가 발생 
               
 ### Inner 클래스 
 - 클래스 안에 클래스를 정의할 수 있다 --> Inner class 
 - 클래스 안에 정의된 클래스가 static으로 선언되어 있을 수 있다. --> nested class 
 
 - Outer 클래스 입장에서는 Nested 클래스의 인스턴스 생성이 외부에 정의된 클래스의 인스턴스 생성과 다를바 없고 외부의 클래스 인스턴스 생성하는 것처럼 생성해준다. 
 - Nested 클래스가 private으로 선언되어 있으면, Outer클래스 내에서만 해당 클래스의 인스턴스 생성이 가능하다. 
 
 - Inner 클래스의 인스턴스는 반드시 Outer 클래스의 인스턴스에 종속되어야하기 때문에 Outer 클래스의 인스턴스 없이는 생성이 불가능. 
    (Outer 클래스의 인스턴스 생성 후에야 Inner 클래스의 인스턴스 생성이 가능하다.)
 - Inner 클래스 내에서는 Outer 클래스에 존재하는 멤버에 직접 접근이 가능하다.
 - Inner 클래스의 인스턴스는 자신이 속할 Outer 클래스의 인스턴스를 기반으로 생성된다.         
 ![innerclass](./img/innerclass.PNG)                  
    --> 그림에서 보이는 것처럼 Inner 클래스의 인스턴스는 Outer 클래스의 인스턴스 내부에 존재하는 방식으로 생성된다. 
 - 하나의 Outer클래스의 인스턴스내에 둘이상의 Inner클래스의 인스턴스가 존재할 수 있다. 
 
 - Inner클래스 & Nested클래싀 의 장점 
    1. 클래스들을 논리적으로 묶는 수단이 된다. 
    2. 클래스들을 논리적으로 묶다 보니, 캡슐화가 증가하는 효과가 있다. 
    3. 결과적으로 코드의 가독성이 향상되고, 유지보수성이 좋아진다. 
    
 ### Local 클래스와 Anonymous 클래스 
 - Local 클래스 
    - Inner클래스와 유사하다
    - but, 메소드 내에 정의가 되고, 정의된 메소드 내에서만 인스턴스의 새성과 참조변수의 선언이 가능하다. 
    - local클래스가 정의되면, local클래스의 인스턴스 접근을 위해서 interface가 함께 정의되는 것이 보통 
 
 - Local 클래스 & 매개변수 
    - local클래스는 메소드 내에 존재하기 때무넹 매개변수와 지역변수에 접근이 가능하다. 
    - but, final로 선언되는 매개변수와 지역변수에만 접근이 가능            
        이유) 매개변수와 지역변수는 메소드를 빠져나가면 소멸되는데 어떻게 접근이 가능한걸까
            --> 컴파일러는 Local클래스에서 접근하는 지역변수와 매개변수의 복사본을, Local클래스가 항상 접근 가능한 메모리 영역에 만들어 둔다 
            --> 그래서 접근 가능!       
            그렇다면 final은?
            --> 만약 final로 선언하지 않으면, local 클래스 안에서 이 값을 변경시킬수 있고 그렇게 되면 원본과 복사본의 값이 일치하지 않는 문제가 발생하기 때문 
 
 - Anonymous 클래스 
    - Local 클래스와 비슷
    - but, 이름이 없다. 
    - 비교적 간단하면서, 이름이 필요없는 클래스를 정의할때 사용
    - interface에 메소드를 채워 넣는 형식으로 정의되는 클래스를 가리켜 Anonymous 클래스로 정의하기도 한다. 
    예시) readable read = new readable()            
          {                  
            public coid read(){...}                     
          }                    
 
 # 자바 기본 공부 18 
 ## 예외처리 (Exception Handing)
 
 ### 예외처리에 대한 이해와 try ~ catch 문의 기본 
 - 자바에서의 '예외' : 프로그램의 실행 도중에 발생하는 문제 상황 (컴파일시 발생하는 문법적인 에러는 예외의 범주에서 벗어남)
    ex) 나이를 입력하라고 했는데, 0 보다 작은 값이 입력되었다. 
        나누기를 0으로 나누었다. 
 - 지금까지는 if문에 의존해서 사용해옴 
 - but, if문은 예외처리 이외의 용도로도 사용되기 때문에 프로그램 코드상에서 예외처리 부분을 구분하기가 쉽지 않다.
 
 - 자바에서 예외처리를 하기 위해 'try-catch' 문을 사용하고 있다. 
 - try ~ catch문 
    - try : 예외상황이 발생할만한 영역을 감싸는 용도로 사용됨 
    - catch : 발생한 예외의 처리를 위한 코드를 묶어두기 위한 용도로 사용됨 
    try{}          
    catch(AAA e){}
    - try 영역에서 발생한 AAA에 해당하는 예외상황은 이어서 등장하는 catch영역에서 처리된다. 
    - AAA e : 가상머신에 의해 생성된 인스턴스의 참조 값이 전달되는 것 (AAA는 예외클래스 : 예외를 알리기 위해 정의된 클래스 - AirthmeticExcption같은것)
    - catch는 메소드와 그 형태가 유사하여 인스턴스의 참조값을 인자로 전달받을 수 있기 때문에, 자바 가상머신은 예외상황 발생시 참조 값의 전달을 통해서 catch 영역으로 실행을 이동시키게 된다.  
    - try 영역에서 예외상황이 발생한 문장의 나머지 부분을 건너뛰기 때문에 try 영역의 구성 범위도 적절해야한다. 
    - 참조변수 e를 통해서 getMessage 메소드(모든 예외 클래스들이 상속하는 Throwable 클래스에 정의되어 있다)를 호출할 수도 있음 
    
 - 예외상황을 알라는 클래스 몇가지 (모두 RuntimeException을 상속하는 하위 클래스들)
    - 배열의 접근에 잘못된 인덱스 값을 사용하는 예외상황 
        --> 예외클래스 : ArrayIndexOutBoundsException
    - 허용할 수 없는 형변환 연산을 진행하는 예외상황 
        --> 예외클래스 : ClassCastException 
    - 배열선언 과정에서 배열의 크기를 음수로 지정하는 예외상황 
        --> 예외클래스 : NegativeArraySizeException
    - 참조변수가 null로 초기화된 상황에서 메소드를 호출하는 예외상황 
        --> 예외클래스 : NullPointerExecption
    
 - catch문은 여러개 있어도 된다. but 위에서 아래로 catch문을 관찰한다. 
    try{}          
    catch(Throwable e){}
    catch(ArithmeticException e){} 
    --> 위 구문은 에러가 난다. 
    --> 모든 예외 클래스가 throwable을 상속하므로, AirthmeticException의 인스턴스도 Throwable형 참조변수의 인자가 될 수 있다. 
    --> 그래서 두번째 catch문은 어떤 상황에서도 실행 불가능 (위치가 바뀌어 있으면 가능)
    
 - 예외 상황의 발생여부와 상관없이 항상 실행되는 영역 : finally 
    - try 영역으로 일단 들어가면 무조건 실행되는 영역 
    
 ### 프로그래머가 직접 정의하는 예외의 상황 
 - 프로그램의 성격에 따라 프로그래머가 정의한 예외상황을 처리하게 하기 위해서는 프로그래머가 예외 클래스를 정의해야 한다. 
 - 필요한 예외 클래스 정의에 필요한 조건 --> Exception 클래스를 상속한다. 
 - Exception 클래스의 생성자 호출을 통해서 전달된 문자열이 getMessage의 호출을 통해서 반환된다.
    - 그래서 예외클래스를 정의할 때, 해당 예외상황의 설명에 필요한 문자열을 Exception 클래스의 생성자에 전달하면 된다. 
 - Throwable 클래스를 상속하지 않고 Exception 클래스를 상속받는 이유 
    - 예외 클래스의 계층도 에서 배움
 - throw excpt;
    --> 예외상황이 발생했음을 알리는 문장 
    --> 이 문장에서 예외상황이 발생했다는 것이 아니라, 예외의 상황은 다른 영역에서 발생하고, 이 문장에서는 throw문을 통해 예외가 발생했음을 알리기만 하는 것 .
    --> throw에 의해 생성된 예외상황이 메소드내에서 처리되지 않는다면, 메소드를 호출한 영역으로 넘어감(던져짐)을 명시해야한다. 
    --> throw에 의해 생성된 예외상황은 반드시 try~catch문에 의해 처리되거나 throws에 의해서 넘겨져야 한다. 
    
 - main 메소드에 throws를 사용해 던진다면, 예외상황이 main 메소드를 호출한 영역으로까지 넘어가게된다. 
    - main메소드는 가상머신이 호출한 메소드 이므로 예외상황 처리가 가상머신에까지 넘어가게되는것 
    - 가상머신의 예외처리 방식 
        - 예외처리1 ) getMessage 메소드를 호출한다. 
        - 예외처리2 ) 예외상황이 발생해서 전달되는 과정을 출력해준다. 
                ex) at ThrowsFromMain.readAge(ThrowsFromMain.java:27)
                    at ThrowsFromMain.main(ThrowsFromMain.java:16)
        - 예외처리3 ) 프로그램을 종료한다. 
        
 - PrintStackTrace
    - ThrowsFromMain.java 의 실행결과로 나온 예외가 발생해서 전달되는 과정은 매우 유용하다. 
    - 이것과 비슷한 출력을 Throwable 클래스에 정의되어 있는 PrintStackTrace 메소드를 이용해 확인할 수 있다. 
    
 ### 예외 클래스의 계층도 
 - Throwable을 상속하는 예외클래스는 Exception과 Error이다. 
 
 - Error 클래스
    - Error는 단순한 예외라고 하기에는 심각한 오류의 상황을 표현하기 위해 정의된 클래스 --> Error를 상속하는 클래스의 오류상황이 발생하면, 그냥 프로그램이 종료되도록 놔두는 것이 상책
    - Error를 상속하는 대표적인 클래스 : VirtualMachineError
    
 - Exception 클래스 
    - Exception은 모든 예외 클래스의 상위클래스이다. 
    - Exception을 상속하는 클래스의 예외상황이 임의의 메소드 내에서 발생 가능하다면, 해당 메소드는 반드시 아래 두가지 중 한개를 해줘야함
        1) try ~catch문을 이용해서 메소드 내에서 예외를 처리하도록 정의
        2) throws를 이용해 메소드를 호출한 영역으로 예외가 전달되도록 정의 
        
 - clone 사용해보기 
    - Object 클래스의 clone 메소드 
    - 이 것은 throws CloneNotSupportedException 하다고 API문서에 적혀있다. 
    그래서 
    1) 
    public void simple(int n)
    {
        mycalss my = new myclass();
        try{
            my.clone();
         } catch (CloneNotSupportedException e) {...}
    }
    2) 
    public void simple(int n) throws CloneNotSupportedException
    {
           mycalss my = new myclass();
           my.clone();
    }
    - 앞으로는 메소드의 호출문을 구성할 때, API문서를 참조해 해당 메소드가 예외를 전달하는지 확인하고, 작성해야한다. 
    
 - 처리하지 않아도 되는 RuntimeException의 하위 클래스 
    - 성격이 Error 클래스와 비슷
    - but, RuntimeException 을 상속하는 예외 클래스는 Error를 상속하는 예외 클래스처럼 치명적인 상황을 표현하지 않음
            따라서 예외발생 이후에도 프로그램의 실행을 이어나가기 위해서 try~catch문으로 해당 예외를 처리하기도 함 
                (예외의 성격이 보여주듯 특별한 경우가 아니면 이들에 대해서 try~catch문을 이용해 예외처리 하지 않음)
    - ex) NegativeArraySizeException, nullPointerException...
 
 # 자바 기본 공부 19
 ## 자바의 메모리 모델과 Object 클래스 
 
 ### 자바 가상머신의 메모리 모델
 - 자바 가상머신은 운영체제 위에서 실행되는 하나의 프로그램이다. 
 - 자바 프로그램은 자바 가상머신 위에서 실행되는 프로그램인다. 
 
 - 자바 가상머신은 운영체제가 할당해주는 메모리 공간을 기반으로 자기 자신도 실행을 하면서, 자바 응용 프로그램의 실행도 돕는다. 
 
 - 가상머신의 메모리 공간은 크게 3개의 영역으로 구분된다. 
    - 메소드 영역 (메소드의 바이트 코드, static 변수)
    - 스택 영역 (지역변수, 매개변수)
    - 힙 영역 (인스턴스)
    
 1) 메소드 영역 
    - 자바 바이트 코드 (자바 가상머신에 의해 실행이 가능한 코드)  들도 메모리 공간에 저장되어 있어야 실행이 가능하다
        --> 따라서, 실행의 흐름을 형성하는 메소드의 바이트코드들은 메소드 영역에 저장됨 
        --> 메소드의 바이트코드는 프로그램의 흐름을 구성하는 바이트코드이다. 이것이 사실상 컴파일된 바이트코드의 대부분이기 때문에 전체 바이트코드가 올라간다고 봐도 됨
    - static으로 선언되는 클래스 변수도 이 영역에 할당이 된다. (물론 static 메소드도 올라간다. 메소드의 바이트코드가 메소드영역에 올라간다고 했기 때문에)
    - 바이트코드와 static변수가 메소드 영역에 저장되는 시점이 '클래스가 메모리에 올려지는 지점'
        --> 즉, 메소드 영역은 클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간이다. 
        
 2) 스택 영역 
    - 지역변수와 매개변수가 저장되는 공간 
        --> 메소드 내에서만 유효한 변수들이 저장됨
    - 지역변수와 매개변수는 선언되는 순간에 스택에 할당되었다가, 자신이 할당된 메소드의 실행이 완료되면 스택에서 소멸된다. 
 
 3) 힙 영역 
    - 인스턴스가 할당된다. (지역변수와 소멸방법과 소멸시점에서 차이가 있어서 스택이 아닌 힙에 할당한다.)
    - 어떠한 참조변수로도 참조가 이뤄지지 않는 인스턴스 존재할 이유 없음 --> 이런것들이 소멸의 대상이 되는것
        --> 어떤 형태로건 참조되지 않는 인스턴스가 소멸의 대상이 되며, 이러한 조건이 충족되었을때 자바 가상머신은 해당 인스턴스를 소멸시킨다 
    - 인스턴스 소멸기능 = 가비지 컬렉션 
    - 힙 영역은 가비지 컬렉션의 대상이 되는 메모리 공간 
 
 ### Object 클래스 
 - finalize 메소드 
    - 인스턴스 소멸 시 반드시 해야 할 일 
    - Object 클래스에는 finalize 라는 이름의 메소드가 정의되어 있음 
        --> protected void finalize() throws Throwable
        --> 인스턴스가 소멸되기 직전에 자바 가상머신에 의해서 자동으로 호출되는 메소드 
        (but, 빈번한 가비지 컬렉션은 프로그램 성능에 문제를 줄 수 있어서, 특정 알고리즘을 통해서 계산된 시기에 가비지 컬렉션이 수행된다.)
        완벽하게 수행해주기 위해서는 아래 두개를 해주어야 한다. 
                // 아래와 같은 메소드 호출을 통해서 명시적으로 가비지 컬렉션을 수행시켜야 한다.
                // 아래의 메소드가 호출되면 자바 가상머신은 가비지 컬렉션을 수행시켜서, 참조되지 않는 인스턴스들을 소멸시킨다.
                // System.gc();
                // 위의 메소드 만으로는 finalize 메소드의 호출을 100% 보장받을 수 없다.
                // 왜냐면, 가비지 컬렉션이 수행되더라도 상황에 따라서 인스턴스의 완전한 소멸은 유보될 수 있기 때문
                // 완전한 소멸이 유보된 인스턴스들의 finalize 메소드 호출은 아래와 같이 별도로 요청해야 한다. 
                // System.runFinalization();
 
 - equals 메소드 
    - == 연산자는 참조변수의 참조 값을 비교한다. 
    - 인스턴스에 저장되어 있는 값 자체를 비교할때 equals를 사용한다. 
    - 인스턴스 내용 비교를 위한 메소드 정의는 Object 클래스에 정의되어 있는 equals 메소드를 활용한다. 
    - equals메소드는 == 연산자와 같이 참조변수의 참조값을 비교하도록 정의되어있음 but, 내용비교를 하도록 오버라이딩 해도 된다. 
    - String 클래스에서는 따로 equals을 오버라이딩하지 않아도 equals는 내용비교를 해주는 메소드이다. 
    
 - clone 메소드
    - 인스턴스의 복사를 위한 메소드가 Object 클래스에 정의되어 있음
        -->  protected Object clone() throws CloneNotSupportedException
        --> 위의 메소드가 호출되면, 이 메소드가 호출된 인스턴스의 복사본이 생성되고, 이 복사본의 참조 값이 반환된다. 
        --> but, Cloneable 인터페이스를 구현해야만 위 메소드를 호출할 수 있다. (= Cloneable 인터페이스를 구현하고 있는 클래스의 인스턴스만이 clone 메소드의 호출이 가능하다.)
    - Clonable 인터페이스는 구현해야할 메소드가 하나도 없는 인터페이스이다. 
    - 하지만 하는 이유) 인터페이스의 또다른 가치인 '다른 클래스와의 구별을 위한 특별한 표시의 목적으로 사용된다' 를 위해 한다 
    - 이 클래스의 인스턴스는 복사를 해도 된다, 그러니 필요하면 clone메소드를 호출해 인스턴스를 복사해라 라는 의미 
    
    - 얕은 복사와 깊은 복사의 차이 
    
    - 인스턴스 변수가 String 인 경우의 깊은 복사 
        - String 인스턴스는 깊은 복사의 대상에 둘 필요가 없다. 
        - String 인스턴스에 저장된 문자열 정보는 변경이 불가능하기 때문이다. 
        - 변경하려면 변경하려는 문자열을 담고 있는 String 인스턴스를 새로 만들어야 한다. (hint)
  
 # 자바 기본 공부 20
 ## 자바의 다양한 기본 클래스
 
 ### Wrapper 클래스
 - 기본 자료형의 데이터를 감싸는 Wrapper 클래스
 - 기본 자료형 데이터들을 인스턴스로 표현해야할 때 사용한다. 
 - 자바에서는 기본 자료형 데이터를 인스턴스로 감싸기 위한 클래스들을 이미 정의해 놓았다. 
    Boolean : Boolean(boolean value)
    Character : Character(char value)
    Byte : Byte(byte value)
    Short : Short(short value)
    Integer : Integer(int value)
    Long : Long(long value)
    Float : Float(float value), Float(double value)
    Double : Double(double value)
    
    --> Character 클래스을 제외한 모든 Wrapper 클래스에는 String의 참조값을 인자로 받는 생성자들이 정의되어 있어서 문자열로 표현된 데이터를 기반으로하는 인스턴스 생성도 가능하다. 
 
 - Boxing & Unboxing 
    - 기본 자료형 데이터를 인스턴스화 시키는 작업 , 인스턴스의 생성에 의해서 이뤄진다. 
    - 인스턴스에 저장되어 있는 기본 자료형 데이터를 꺼내는 작업, Wrapper 클래스에 정의된 메소드의 호출에 의해서 이뤄진다. 
    
 - Wrapper 클래스는 산술연산을 위해서 정의된 클래스가 아니다. 
    - Wrapper 클래스의 인스턴스에 저장된 값은 변경이 불가능하다. 
    - 변경된 값을 저장하는 새로운 인스턴스의 생성 및 참조만 가능하다. 
    - but, 자동박싱, 자동언박싱이 가능해지면서 산술연산이 가능해졌다. 
 
 ### BigInteger 클래스와 BigDecimal 클래스
 - 매우 큰 정수를 표현하는 BigInteger 클래스는 new BigInteger("") 와 같이 문자열 매개변수로 받는다. 
    - 큰 수를 전달받을 수 있는 매개변수 선언이 불가능하기 때문이다. 
 - 오차없는 실수의 표현을 위한 BigDecimal 클래스 
 
 ### Math 클래스와 난수의 생성, 그리고 문자열 토큰의 구분    
 - 수학관련 기능의 제공을 위한Math 클래스 (모든 멤버가 static으로 선언되어 있음)
 - 수학관련 기능의 제공을 위해 정의된 클래스일뿐, 인스턴스 생성을 목적으로 정의된 클래스는 아니다. 
 - Random rand = new Random() --> 이렇게 인스턴스를 생성하여 난수를 만든다. 
    ()안에 숫자를 넣을 수 있는데 이 수는 씨드값이 된다. 그 값을 기준으로 난수를 생성한다는 뜻이다. 
    그렇게 되면 씨앗이 같으면 생성되는 난수는 같아지게 된다. 
    그래서 setSeed(System.currentTimeMillis()) 를 사용해 시간에 맞춰 씨드값을 계속 변경해주는 방식을 사용하기도 한다. 
    random메소드를 사용하기도 한다. 
 
 # 자바 기본 공부 21 
 ## 제네릭 
 
 ### 제네릭 클래스의 이해와 설계
 - 일반화 한다는 뜻을 담고 있다. 
 - class FruitBox<T> : 이 클래스의 인스턴스를 생성하려면 자료형 정보를 인자로 전달해야한다! 전달되는 인자는 클래스 내에 존재하는 T를 대체해서 인스턴스가 생성이 된다. 
    ex) FruitBox<Orange> orBox = new FruitBox<Orange>();
 - 하나의 클래스 정의로 둘 이상의 클래를 정의한 효과를 제네릭이 가져다 주고있다. 
 
 ### 제네릭을 구성하는 다양한 문법적 요소 
 - 클래스 전부가 아닌 특정 메소드에 대해서만 제네릭으로 선언하는 것을 허용한다. 
 - 제네릭 클래스, 메소드에 둘 이상의 자료형 매개변수를 선언하고 각각에 다른 자료형 정보를 전달할 수 있다. 
 - 기본저긍로 제네릭 메소드 내에서는 제네릭으로 선언된 참조변수를 통해서 Object클래스에 정의된 메소드만 호출이 가능하다. 
    이는 모든 자료형을 기반으로 실행이 가능하도록 하기 위함이다. 
 - 제네릭의 자료형 제한에는 클래스와 인터페이스를 구분하지 않고 두경우 모두 extends를 사용한다. 
 - 배열 인스턴스도 제네릭 매개변수에 전달이 가능하다. (배열의 제네릭 매개변수 선언을 T[] arr 로만 해주면 매개변수에 전달되는 대상을 배열의 인스턴스로 제한할 수 있다.)
 - *.class 에서 *과 같이 자바에서의 와일드 카드는 ? 로 표시된다. 
    ex) FruitBox< ? extends Fruit> box = new FruitBox<Fruit>();
        < ? extends Fruit> : Fruit을 상속하는 모든 클래스 
        new FruitBox<Fruit>() : Fruit자리에는 'Fruit클래스, Fruit를 상속하는 클래스의 이름'이 올수 있다. 
    ex) 전달되는 자료형에 상관없이 FruitBox<T>의 인스턴스를 참조하려면 FruitBox<?> box; == FruitBox<? extends Object> box;
 - <? super Apple> : Apple이 상속하는 클래스라면 무엇이든지 
 - <? extends Apple> : Apple을 상속하는 클래스라면 무엇이든지 
 - 기본 자료형의 이름은 제네릭 클래스의 인스턴스 생성에 사용될 수 없다. 
    ex) FruitBox<int> fb1 = new FruitBox<int>();
 
 # 자바 기본 공부 22 
 ## 컬렉션 프레임워크
 
 ### 컬렉션 프레임워크의 이해 
 - 프레임워크 : 잘 정의된, 약속된 구조의 클래스들 
 - 컬렉션 라이브러리가 아닌 컬렉션 프레임워크 라고 하는 이유 : 컬렉션과 관련된 클래스들의 정의에 적용되는 설계의 원칙, 또는 구조가 존재하기 때문
 
 - 자료구조 : 데이터의 저장과 관련있는 학문 - 배열, 리스트, 스택 ,큐, 트리, 해시
 - 알고리즘 : 저장된 데이터의 일부, 또는 전체를 대상으로 진행하는 각종 연산을 연구하는 학문 - 정렬, 탐색, 최대, 최소 검색
 - 컬렉션은 데이터의 저장, 그리고 이와 관련 있는 알고리즘을 구조화 해놓은 프레임워크 
 
 - [컬렉션 프레임워크의 인터페이스 구조](https://user-images.githubusercontent.com/28684368/42793450-1ec51524-89b5-11e8-8cac-ec1d2ce5f4f7.JPG)
 - 모든 인터페이스가 제네릭으로 정의되어 있음 
 
 ### Collection<E> 인터페이스를 구현하는 제네릭 클래스들 
 - Collection<E> 인터페이스를 구현하는 제네릭 클래스들은 모두 인스턴스를 저장의 대상으로 삼는다. 
 
 - List<E> 인터페이스와 이를 구현하는 제네릭 클래스 ArrayList<E> , LinkedList<E> 
    - 특성1. 동일한 인스턴스의 중복저장을 허용한다.
    - 특성2. 인스턴스의 저장 순서가 유지된다. 
    
    - ArrayList<E> : 배열과 유사, 그러나 데이터 저장을 위해서 인덱스 정보를 별도로 관리할 필요도 없고, 데이터 삭제를 위한 추가적인 고드 작성이 필요없다. 또한 저장되는 인스턴스의 수에 따라 그 크기도 자동으로 늘어나기 때문에 배열과 달리 길이를 고민하지 않아도 된다. 
        - 내부적으로 배열을 이용하기 떄문에 
            1. 저장소의 용량을 늘리는 과정에서 많은 시간이 소요된다.
                (배열은 한번 생성되면 그 길이를 변경할 수 없는 인스턴스이므로 새로 인스턴스를 생성하고 복사가 필요하다.)
            2. 데이터의 삭제에 필요한 연산과정이 매우 길다. 
            3. 데이터의 참조가 용이해서 빠르 참조가 가능하다. 
    - LinkedList<E> : 서로서로 연결하는 방식으로 데이터를 저장 
        - 리스트 자료구조를 사용하기 때문에 
            1. 저장소의 용량을 늘리는 과정이 간단하다. 
            2. 데이터의 삭제가 매우 간단하다. 
            3. 데이터의 참조가 다소 불편하다.
            
 - Collection<E> 인터페이스에는 'Iterator<E> iterator()' 메소드가 정의되어 있다. 
    - 해당 메소드가 호출되면 인스턴스가 한개 생성되는데, 이 인스턴스는 Iterator<E> 인터페이스를 구현하는 클래스의 인스턴스이다. 
    - 그리고 iterator 메소드는 이 인스턴스의 참조값을 반환하다. 
    - Iterator 인터페이스에 정의 되어 있는 메소드 
        - boolean hasNext()
        - E next()
        - void remove() : 현재위치의 요소 삭제 
    - get 메소드도 있는데 반복자를 사용하는 이유?
        - 데이터의 저장순서가 유지되지 않는 컬렉션 클래스들도 있고 이들은 get메소드를 사용할 수 없기 때문에 
        - 반복자는 컬렉션 클래스의 종류에 상관없이 동일한 형태의 데이터 참조방식을 유지한다. 
  
 - 제네릭은 기본자료형을 기반으로 인스턴스를 생성할 수 없기 때문에 컬렉션 클래스도 기본 자료형을 기반으로 인스턴스를 만들수 없다. 
 - 그러나 auto boxing, auto unboxing을 통해 기본자료형 데이터를 저장하는 것을 만들수 있다. 
 
 ### Set<E> 인터페이스를 구현하는 컬렉션 클래스들 
 - 특징1. 데이터의 저장순서를 유지하지 않는다. 
 - 특징2. 데이터의 중복저장을 허용하지 않는다. 
 --> 수학에서 '집합'의 특성 
 
 - HashSet<E> 클래스
    - 해시 알고리즘을 적용하여 데이터를 저장하고 검색한다.
        1. 매우빠른 검색 속도 
        2. 매우 빠른 데이터의 저장 
            (검색과 관련된 메소드 제공하지 않음. 그러나 동일한 데이터가 이미 저장되있는지 검색을 하고 저장하므로 빠른검색, 빠른저장)
    - 검색 단계
        - 1단계 : Object 클래스의 hashCode 메소드의 반환값을 해시값으로 이용
        - 2단계 : Object 클래스의 equals 메소드의 반환 값을 이용해서 내용비교
        // 동일한 것은 하나만 저장되도록 hashCode 메소드와 equals 메소드를 오버라이딩 할 필요가 있다. 
 
 - TreeSet<E> 클래스 
 
 ### Map<K,V> 인터페이스를 구현하는 컬렉션 클래스들 
 
 # 자바 기본 공부 25
 ## Swing 컴포넌트와 이벤트 헨들링
 
 ### Swing을 시작하기에 앞서
 - Swing은 GUI를 만드는데 사용되는 자바 패키지 이름이다. 
 
 ### Swing 컴포넌트와 이벤트 핸들링
 - JFrame은 java.awt.Container 를 상속한다. 
    - java.awt.Container 클래스를 상속하는 모든 클래스는 "다른 Swing 컴포넌트를, 그리고 AWT 컴포넌트를 얹을 수 있다"는 특징을 가지게 된다. 
    - JButton과 같은 다른 Swing 컴포넌트를 위에 얹을 수 있는 컨테이너 역할을 하는 컴포넌트이다. 
 - 그래서 JButton 인스턴스를 add 메소드의 호출을 통해 JFrame의 위에 얹을 수 있는 것이다. 
 - 버튼을 눌렀을때와 같은 이벤트 처리를 위한 'Event Listener' 
 - MouseEvent의 인스턴스에는 발생한 이벤트와 관련된 정보가 담겨있다. 
    - 이벤트가 발생한 위치정보 : getX, getY 정보 
    - 이벤트가 발생한 인스턴스의 참조 값 :  getComponent 메소드 
    - 이벤트를 발생시킨 마우스 버튼의 종류 : getButton 메소드
 
 ### 레이아웃 매니저 (Layout Manager)
 - FlowLayout
 - BorderLayout
 - GridLayout
 
 - 두개 이상의 레이아웃을 넣고 싶을 때는 JPanel을 사용한다. 
    - JFrame에 넣고 싶은 레이아웃개수만큼 JPanel을 만들고 JPanel을 JFrame에 add해주면 된다. 
 
 ### 이벤트와 이벤트 리스너 
 - MouseEvent : MouseListener : MouseAdapter :마우스 관련 이벤트 
 - MouseEvent : MouseMotionListener : MouseMotionAdapter : 마우스 움직임 관련 이벤트 
 - TextEvent : TextListener : 없음(구현해야할 메소드가 한개인 인터페이스이므로) : 텍스트 관련 컴포넌트의 문자 편집 이벤트 
 - ItemEvent : ItemListener : 없음 : 선택 관련 이벤트 
 - AdjustmentEvent : AdjustmentListener : 없음 : 스크롤바 이벤트 
 - WindowEvent : WindowListener : WindowAdapter : GUI 프레임 창 관련 이벤트 
 - ActionEvent : ActionListener : 없음 : 컴포넌트 별 특정 행위 관련 이벤트 
 
 - ActionEvent 중 한개는 JButtondl 눌렸을때 가 있다. 이것은 버튼을 마우스로 클릭했을 때와는 다른것이다. 
    - JButton을 누르는 방법은 매우 여러개가 있기 때문이다. 
 
 - MouseListener 인터페이스와 마찬가지로 구현해야할 메소드가 둘 이상인 이벤트 처리 관련 인터페이스에 대해서는 해당 인터페이스를 구현하는 클래스가 제공된다 --> 어댑터 클래스 
 
 ### 다양한 Swing 컴포넌트 
 - JLabel : 문자열 정보를 출력하기 위한 컴포넌트
 - JTextField : 한줄의 문자열 입력을 위한 컴포넌트 
 - JTextArea : 여러줄의 문자열 입력을 위한 컴포넌트 
 - JScrollPane : 스크롤 바 
 - JCheckBox : 체크박스 
 - JRadioButton : 라디오 버튼 
 - Border : JPanel 컴포넌트의 경계표시를 돕는 클래스 
 - JComboBox : 펼쳐지는 선택목록에서 하나를 선택하는 경우에 사용되는 컴포넌트 
 - Look And Feel : GUI창의 다른 느낌을 주는 것 
 
 
 ** [API 참조 문서 주소](https://docs.oracle.com/javase/8/docs/api/index.html) 참고할 API 문서 