#### 자바 기본서를 읽으면서 내가 몰랐던 부분 혹은 기록하고 싶은 부분만을 적어둠. 전부를 적어두는 것이 아님. 

# 자바 기본 공부 1
## 자바 프로그램의 실행 구조와 자바 가상머신 
__다른 프로그램들__ 은 운영체제가 직접 실행시키는 구조이지만 __자바 프로그램__ 은 자바 가상머신에 의해서 실행되는 구조이다.    
그 이유는 자바 프로그램을 운영체제에 상관없이 실행 시키기 위함이다. 운영체제에 따른 차이점을 자바 가상머신이 대신해주는 것이다. 그래서 가상머신은 운영체제에 따라 다르다.     

## 자바 컴파일러와 자바 바이트코드    
자바 컴파일러에 의해서 생성되는 코드를 __자바 바이트코드__ 라고 한다. 자바 컴파일러에 의해 생성되는 코드의 명령어 크기가 1바이트 이기 때문이다.     
과정을 살펴보면 자바의 소스코드가 __javac.exe__ 에 의해서 컴파일되고, 해당 파일이 __java.exe__ 에 의해서 가상머신을 기반으로 실행이 되는 것이다.      

## 프로그램의 골격과 구성 
클래스 이름이 Myclass이면 컴파일시 생성되는 파일의 이름은 Myclass.class이다. 

# 자바 기본 공부 2
## 변수
- 변수 : 데이터의 저장과 참조를 위해 할당된 메모리 공간    
- 자바에서 제공하는 기본 자료형 : boolean, char, byte, short, int, long, float, double     
- 실수의 표현에서 오차가 존재한다. 
    - 정밀도를 포기하고 표현의 범위를 넓히고자 했었다. 
    - float와 double을 선택할 때에도 정밀도를 기반으로 채택 
    - float는 6자리의 정밀도, double은 15자리의 정밀도를 가지고 있다. 
    - 큰 실수형을 표현하기 위해, e를 사용함. (e-3 은 10의 -3승을 의미한다.)
- 자바는 정수형 연산을 진행할 때, 모든 피연산자를 int형으로 변환하는 과정을 거친다. (int형이 정수연산을 가장 고속으로 처리하게끔 설계되어있기 때문 - int보다 작은 레벨의 자료형에서만, long은 int로 변환되지 않음)
- 변수의 이름 제한사항 
    - 변수의 이름은 숫자로 시작할 수 없음 
    - $와 _ 이외의 다른 특수문자 사용 불가. 
    - 키워드(자바의 문법을 구성하는 단어들)는 변수의 이름으로 사용 불가.    
- 문자 : 자바는 유니코드라는 표준을 근거로 문자를 표현한다. 그래서 자바에서 문자 하나를 변수에 저장하면 실제로는 해당 문자의 유니코드 값이 저장되는 것이다.     
    - 문자는 작은 따옴표로 표현이 된다. 

# 자바 기본 공부 3
## 상수와 형 변환 
- 상수 : 메모리 공간에 값이 저장은 되지만, 변수와 달리 저장된 값의 변경이 불가능하다. (변수와 달리 이름이 없기 때문에 메모리 공간에 접근 하지 못하므로)    
- 기본적으로 모든 정수형 상수는 int형으로 표현 및 저장한다. 그렇기 때문에 long num = 10000000 으로 하면 에러가 난다. int로 표현 저장하기 때문이다. 그래서 10000000L 로 표기해서 이정수를 long형으로 표현해달라고 해야한다. 
- 기본적으로 모든 실수형 상수는 double형으로 표현 및 저장한다. 이것도 마찬가지고 float num = 12.45로 하면 에러가 난다. 12.45F로 표현해야 한다. 
- 연산을 할때에는 자료형을 한개로 통일시켜 주어야 한다. --> 자바에서는 '자동 형 변환' 이라는 과정을 통해 CPU가 연산을 할 수 있도록 자료형을 하나로 일치시켜 준다. 
![자동형변환]()
- 가급적이면 자동으로 형 변환이 발생하는 위치에 명시적으로 형 변환이 됨을 표현하는 것이 좋다.    

# 자바 기본 공부 4 
## 연산자 
- 이항 연산자 : 피연산자가 두개인 연산자
- 연산자들의 우선순위로 인한 실수를 줄이기 위해 소괄호를 이용하는 경우가 많음. 
- 실수를 이용한 % 연산의 결과는 의미가 없으니 이런 연산문은 만들지 않도록 하는게 중요하다.    
- short circuit Evaluation (SCE = Lazy Evaluation): 가장 빠르게 연산을 진행하기 위한 계산 방식
    > SCE 코드를 통해 설명해둠. 
- 비트 연산자(&, |, ^, ~)의 피연산자는 반드시 정수여야 한다. 실수에 대해서는 비트연산이 불가능하다. 
- 비트연산자는 비트단위로 연산을 진행하고 그 연산의 결과를 묶어서 하나의 연산결과를 반환한다. 

# 자바 기본 공부 5 
## 살행흐름의 컨트롤 
- 조건문 
- 조건 연산자 : < true or false ? 숫자1 : 숫자2 > 로 표현한다. 
    - ? 왼편에 true가 등장하면 숫자1이 반환된다. 
- switch문 : switch, case, default, break로 구성됨. break가 없으면 모든 문장을 다 거치고 break가 있다면 거기서 switch문은 끝이 난다. 
- while 반복문 
    - 반복조건을 먼저 검사한 후에 반복영역의 실행여부를 결정한다. (검사결과가 true이면 반복영역이 실행됨)
    - 반복조건을 먼저 검사하기 때문에 반복영역이 한차례도 실행되지 않을 수 있다. 
    - 무한루프에 빠지지 않도록 조심해야한다. 
- do~while 반복문 
    - while 반복문과 다르게 반복영역이 한번은 무조건 실행됨. 
- for 반복문 
    - 반복변수를 초기화한후 반복조건이 만족되었는지 확인후 만족되었으면 반복영역을 실행함. 
    - 반복영역이 실행된 후 변수의 값이 작성된 것에 기반하여 변화한다. 
- break 
    - 가장 가까이에있는 반복문 한개를 빠져나가기 위한 용도로 사용됨. 
    - 상황에 따라 중첩된 반복문 모두를 나가야 하는 경우도 발생한다. 이럴때는 outerLoop : for(~,~,~) 로 반복문을 설정하고 , 빠져 나오고 싶은곳에 break outerLoop 를 써서 빠져나오면 된다. 
- continue
    - 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건검사 부분으로 이동시킴. 
 
# 자바 기본 공부 6
## 메소드와 변수의 스코프 

### 메소드 
- 자바 프로그램의 시작은 main이라는 이름의 메소드를 실행하는 데서부터 시작한다. 
- 프로그램 진행중, 메소드 호출문을 접하면, 해당 메소드의 실행이 완료된 다음에야 비로소 그 다음을 실행하게 된다. 
- 메소드가 정의되는 위치는 프로그램에 영향을 미치지 않음 
- 매개변수(parameter) : 메소드 이름 오른쪽 
    - 메소드 호출 시 전달되는 값의 저장을 위한 용도로 사용됨 --> 그래서 메소드 호출 시 전달되는 값의 자료형과 매개변수의 자료형은 일치해야함
- 반환 : 메소드 이름 왼쪽에 자료형은 반환값의 자료형 
    - void : 값을 반환하지 않는다. 
    - return 문을 실행하게 되면 메소드는 종료가 되고 메소드를 호출한 영역으로 값은 반환이 된다. 
    - 오직 한개의 값만 반환할 수 있다. 
    - return 이 가지는 2가지 의미 
        - 값의 반환 & 메소드의 종료
        - void에서도 return; 을 사용해 메소드 종료 가능 
        
        
### visibility 
- 지역변수 
    - 중괄호로 영역이 형성되면, 감싸이는 영역은 변수에 관한 별도의 스코프를 형성함. 
    - 변수는 자신이 속한 중괄호 내에서만(선언된 이후부터) 접근이 가능하다. --> 속한 영역이 다르면 이름이 동일할지라도 문제가 되지 않음
    - for문의 일부로 선언되는 변수, 메소드의 매개변수도 이어서 등장하는 중괄호 내에서만 접근이 가능하다. --> 그래서 매개변수에서 num이라는 변수를 사용했다면 그 중괄호 안에서는 이제 그 이름의 변수를 쓸수없다. 
    - 지역변수는 선언된 지역을 벗어나 버리면 메모리 공간에서 자동 소멸된다. 
    
### 메소드의 재귀호출 
- 아직 실행이 완료되지 않은 메소드를 어떻게 다시 호출하나?
    - 메모리에 저장된 메소드를 구성하는 명령문은 CPU로 이동해서 실행이 된다.
- 잘못된 재귀 메소드의 정의 --> 종료조건이 없다...!
    예시) InfRecul class 코드를 보면 cnt를 감소시켜 주기는 하지만 cnt--로 감소시켜 주어서 메소드가 호출이 된다음에야 감소된다. 
        그래서 이 코드는 무한히 돌게되는 것 --> --cnt로만 바꾸어도 해결가능 
        but 이렇게 한다고 해도, 재귀는 계속된다. 9-10행이 실행되지 않기 때문이다. 
        이것들의 위치를 8행과 바꾸면된다. 
        
    - 재귀의 연결 고리를 끊기 위한 조건검사의 위치가 적절해야한다.
    - 재귀의 연결 고리를 끊기 위한 조건검사가 true가 될 수 있도록 적절한 연산이 이루어져야 한다. 
 - 과도한 재귀의 사용은 메모리를 너무 많이 사용하게 하여 성능저하를 일으킬 수 있다. 