#### 자바 기본서를 읽으면서 내가 몰랐던 부분 혹은 기록하고 싶은 부분만을 적어둠. 전부를 적어두는 것이 아님. 

# 자바 기본 공부 1
## 자바 프로그램의 실행 구조와 자바 가상머신 
__다른 프로그램들__ 은 운영체제가 직접 실행시키는 구조이지만 __자바 프로그램__ 은 자바 가상머신에 의해서 실행되는 구조이다.    
그 이유는 자바 프로그램을 운영체제에 상관없이 실행 시키기 위함이다. 운영체제에 따른 차이점을 자바 가상머신이 대신해주는 것이다. 그래서 가상머신은 운영체제에 따라 다르다.     

## 자바 컴파일러와 자바 바이트코드    
자바 컴파일러에 의해서 생성되는 코드를 __자바 바이트코드__ 라고 한다. 자바 컴파일러에 의해 생성되는 코드의 명령어 크기가 1바이트 이기 때문이다.     
과정을 살펴보면 자바의 소스코드가 __javac.exe__ 에 의해서 컴파일되고, 해당 파일이 __java.exe__ 에 의해서 가상머신을 기반으로 실행이 되는 것이다.      

## 프로그램의 골격과 구성 
클래스 이름이 Myclass이면 컴파일시 생성되는 파일의 이름은 Myclass.class이다. 

# 자바 기본 공부 2
## 변수
- 변수 : 데이터의 저장과 참조를 위해 할당된 메모리 공간    
- 자바에서 제공하는 기본 자료형 : boolean, char, byte, short, int, long, float, double     
- 실수의 표현에서 오차가 존재한다. 
    - 정밀도를 포기하고 표현의 범위를 넓히고자 했었다. 
    - float와 double을 선택할 때에도 정밀도를 기반으로 채택 
    - float는 6자리의 정밀도, double은 15자리의 정밀도를 가지고 있다. 
    - 큰 실수형을 표현하기 위해, e를 사용함. (e-3 은 10의 -3승을 의미한다.)
- 자바는 정수형 연산을 진행할 때, 모든 피연산자를 int형으로 변환하는 과정을 거친다. (int형이 정수연산을 가장 고속으로 처리하게끔 설계되어있기 때문 - int보다 작은 레벨의 자료형에서만, long은 int로 변환되지 않음)
- 변수의 이름 제한사항 
    - 변수의 이름은 숫자로 시작할 수 없음 
    - $와 _ 이외의 다른 특수문자 사용 불가. 
    - 키워드(자바의 문법을 구성하는 단어들)는 변수의 이름으로 사용 불가.    
- 문자 : 자바는 유니코드라는 표준을 근거로 문자를 표현한다. 그래서 자바에서 문자 하나를 변수에 저장하면 실제로는 해당 문자의 유니코드 값이 저장되는 것이다.     
    - 문자는 작은 따옴표로 표현이 된다. 

# 자바 기본 공부 3
## 상수와 형 변환 
- 상수 : 메모리 공간에 값이 저장은 되지만, 변수와 달리 저장된 값의 변경이 불가능하다. (변수와 달리 이름이 없기 때문에 메모리 공간에 접근 하지 못하므로)    
- 기본적으로 모든 정수형 상수는 int형으로 표현 및 저장한다. 그렇기 때문에 long num = 10000000 으로 하면 에러가 난다. int로 표현 저장하기 때문이다. 그래서 10000000L 로 표기해서 이정수를 long형으로 표현해달라고 해야한다. 
- 기본적으로 모든 실수형 상수는 double형으로 표현 및 저장한다. 이것도 마찬가지고 float num = 12.45로 하면 에러가 난다. 12.45F로 표현해야 한다. 
- 연산을 할때에는 자료형을 한개로 통일시켜 주어야 한다. --> 자바에서는 '자동 형 변환' 이라는 과정을 통해 CPU가 연산을 할 수 있도록 자료형을 하나로 일치시켜 준다. 
![자동형변환]()
- 가급적이면 자동으로 형 변환이 발생하는 위치에 명시적으로 형 변환이 됨을 표현하는 것이 좋다.    

# 자바 기본 공부 4 
## 연산자 
- 이항 연산자 : 피연산자가 두개인 연산자
- 연산자들의 우선순위로 인한 실수를 줄이기 위해 소괄호를 이용하는 경우가 많음. 
- 실수를 이용한 % 연산의 결과는 의미가 없으니 이런 연산문은 만들지 않도록 하는게 중요하다.    
- short circuit Evaluation (SCE = Lazy Evaluation): 가장 빠르게 연산을 진행하기 위한 계산 방식
    > SCE 코드를 통해 설명해둠. 
- 비트 연산자(&, |, ^, ~)의 피연산자는 반드시 정수여야 한다. 실수에 대해서는 비트연산이 불가능하다. 
- 비트연산자는 비트단위로 연산을 진행하고 그 연산의 결과를 묶어서 하나의 연산결과를 반환한다. 

# 자바 기본 공부 5 
## 살행흐름의 컨트롤 
- 조건문 
- 조건 연산자 : < true or false ? 숫자1 : 숫자2 > 로 표현한다. 
    - ? 왼편에 true가 등장하면 숫자1이 반환된다. 
- switch문 : switch, case, default, break로 구성됨. break가 없으면 모든 문장을 다 거치고 break가 있다면 거기서 switch문은 끝이 난다. 
- while 반복문 
    - 반복조건을 먼저 검사한 후에 반복영역의 실행여부를 결정한다. (검사결과가 true이면 반복영역이 실행됨)
    - 반복조건을 먼저 검사하기 때문에 반복영역이 한차례도 실행되지 않을 수 있다. 
    - 무한루프에 빠지지 않도록 조심해야한다. 
- do~while 반복문 
    - while 반복문과 다르게 반복영역이 한번은 무조건 실행됨. 
- for 반복문 
    - 반복변수를 초기화한후 반복조건이 만족되었는지 확인후 만족되었으면 반복영역을 실행함. 
    - 반복영역이 실행된 후 변수의 값이 작성된 것에 기반하여 변화한다. 
- break 
    - 가장 가까이에있는 반복문 한개를 빠져나가기 위한 용도로 사용됨. 
    - 상황에 따라 중첩된 반복문 모두를 나가야 하는 경우도 발생한다. 이럴때는 outerLoop : for(~,~,~) 로 반복문을 설정하고 , 빠져 나오고 싶은곳에 break outerLoop 를 써서 빠져나오면 된다. 
- continue
    - 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건검사 부분으로 이동시킴. 
 
# 자바 기본 공부 6
## 메소드와 변수의 스코프 

### 메소드 
- 자바 프로그램의 시작은 main이라는 이름의 메소드를 실행하는 데서부터 시작한다. 
- 프로그램 진행중, 메소드 호출문을 접하면, 해당 메소드의 실행이 완료된 다음에야 비로소 그 다음을 실행하게 된다. 
- 메소드가 정의되는 위치는 프로그램에 영향을 미치지 않음 
- 매개변수(parameter) : 메소드 이름 오른쪽 
    - 메소드 호출 시 전달되는 값의 저장을 위한 용도로 사용됨 --> 그래서 메소드 호출 시 전달되는 값의 자료형과 매개변수의 자료형은 일치해야함
- 반환 : 메소드 이름 왼쪽에 자료형은 반환값의 자료형 
    - void : 값을 반환하지 않는다. 
    - return 문을 실행하게 되면 메소드는 종료가 되고 메소드를 호출한 영역으로 값은 반환이 된다. 
    - 오직 한개의 값만 반환할 수 있다. 
    - return 이 가지는 2가지 의미 
        - 값의 반환 & 메소드의 종료
        - void에서도 return; 을 사용해 메소드 종료 가능 
        
        
### visibility 
- 지역변수 
    - 중괄호로 영역이 형성되면, 감싸이는 영역은 변수에 관한 별도의 스코프를 형성함. 
    - 변수는 자신이 속한 중괄호 내에서만(선언된 이후부터) 접근이 가능하다. --> 속한 영역이 다르면 이름이 동일할지라도 문제가 되지 않음
    - for문의 일부로 선언되는 변수, 메소드의 매개변수도 이어서 등장하는 중괄호 내에서만 접근이 가능하다. --> 그래서 매개변수에서 num이라는 변수를 사용했다면 그 중괄호 안에서는 이제 그 이름의 변수를 쓸수없다. 
    - 지역변수는 선언된 지역을 벗어나 버리면 메모리 공간에서 자동 소멸된다. 
    
### 메소드의 재귀호출 
- 아직 실행이 완료되지 않은 메소드를 어떻게 다시 호출하나?
    - 메모리에 저장된 메소드를 구성하는 명령문은 CPU로 이동해서 실행이 된다.
- 잘못된 재귀 메소드의 정의 --> 종료조건이 없다...!
    예시) InfRecul class 코드를 보면 cnt를 감소시켜 주기는 하지만 cnt--로 감소시켜 주어서 메소드가 호출이 된다음에야 감소된다. 
        그래서 이 코드는 무한히 돌게되는 것 --> --cnt로만 바꾸어도 해결가능 
        but 이렇게 한다고 해도, 재귀는 계속된다. 9-10행이 실행되지 않기 때문이다. 
        이것들의 위치를 8행과 바꾸면된다. 
        
    - 재귀의 연결 고리를 끊기 위한 조건검사의 위치가 적절해야한다.
    - 재귀의 연결 고리를 끊기 위한 조건검사가 true가 될 수 있도록 적절한 연산이 이루어져야 한다. 
 - 과도한 재귀의 사용은 메모리를 너무 많이 사용하게 하여 성능저하를 일으킬 수 있다. 
 
 # 자바 기본 공부 7
 ## 클래스와 인스턴스 
 
 ### 클래스의 정의와 인스턴스의 생성
 - 객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화시키는 형태의 프로그래밍. 
 - 객체를 이루는 것은 '데이터' & '기능'
 > 나는 과일장수에게 2000원을 주고 두개의 사과를 구매했다       

 위의 문장을 객체화하는 연습을 해보겠다 
 1. 객체 나누기 
    - 나, 과일장수, 사과 가 될 수 있다. 
    - 나, 과일장수만 객체로 인식하여 문제를 풀어보겠다
    
 2. 과일장수 객체를 이루는 것 
    - 과일장수는 과일을 판다. ---> 과일장수의 행위 <기능>
    - 과일장수는 사과 20개, 오렌지 10개를 가지고 있다. ---> 과일장수의 상태 <데이터>
    - 과일장수의 과일판매 수익은 50000원이다. 
    
    상태정보는 변수를 통해 표현되고, 행동은 메소드를 통해 표현된다. 
    
    - 변수 
        - 보유하고 있는 사과의 수 : int numOfApple;
        - 판매 수익 : int myMoney
    
    - 메소드 
        int saleApple(int money){       // 사과 구매액이 인자로 전달됨 
            int num = money / 1000;     // 사과 한개당 1000원이라고 가정 
            numOfApple -= num           // 팔린 사과의 수만큼 보유중인 사과수 줄이기 
            myMoney += money            // 판매 수익 발생 
            return num                  // 실제 구매가 발생한 사과의 수를 반환
        }
        
 3. 과일장수 클래스 정의 --> class라는 틀을 기반으로 객체 생성 
    - 객체를 생성하기 앞서 객체의 생성을 위한 틀(mold) 만들어야함. 틀 = class 
    - FruitSeller 라는 틀을 정의
        class FruitSeller
        {
            // 변수 선언 
            int numOfApple = 20;
            int myMoney = 0;
            
            // 메소드 정의 
            public int saleApple(int money)
            {
                int num = money / 1000;
                //동일클래스에 해당 변수가 있으므로 접근 가능 
                numOfApple -= num;
                myMoney += money;
                return num;
            }
        }
        
 4. 메소드 추가해보기 
    - 남은사과와 판매수익을 보여주는 메소드 추가 
                class FruitSeller
                {
                    // 사과가격
                    final int APPLE_PRICE = 1000;
                    // 변수 선언 
                    int numOfApple = 20;
                    int myMoney = 0;
                    
                    // 메소드 정의 
                    public int saleApple(int money)
                    {
                        int num = money / 1000;  ---> int num = money / APPLE_PRICE; 
                        //동일클래스에 해당 변수가 있으므로 접근 가능 
                        numOfApple -= num;
                        myMoney += money;
                        return num;
                    }
                    
                    // 추가된 메소드
                    public void showSaleResult()
                    {
                        System.out.println("남은사과: " + numOfApple);
                        System.out.println("판매수익: " + myMoney);
                    }
                        
                }      
    - final 변수
        - 변수가 상수화 된 것이기 때문에 final 상수라고도 부름 
        - 한번 값이 결정된 이 변수의 값은 변경이 불가능하다. 
        - 지역변수가 final 로 선언되면 딱 1번 초기화가 가능하다. 
                
 5. 나 클래스 정의
     - 변수 
         - 소유하고 있는 현금 : int myMoney
         - 소유하고 있는 사과의 수 : int numOfApple 
        
        class FruitBuyer
        {
            int myMoney = 5000;
            int numOfApple = 0;
            public void buyApple(FruitSeller seller, int money)
            {
                numOfApple+=seller.saleApple(money);
                moMoney-=money;
            }
            public void showButResult()
            {
                System.out.println("사과개수: " + numOfApple);
                System.out.println("현재잔액: " + myMoney);
            }
            
 6. 클래스 기반으로 객체 생성하기 
    - 객체 생성 방법 : ClassName name = new ClassName();
        - ClassName 객체를 생성하고 이를 name이라는 이름의 변수로 참조한다 라는 의미 
        - new에 의해 객체 생성시 생성된 객체는 메모리에 저장되고, 저장된 메모리의 주소값(참조값)이 반환되어 참조변수에 저장된다.          - 그래서 참조변수에 의한 객체 접근이 가능한 것.
        - new 키워드 : 객체 생성을 명령하는 명령어
    - 이렇게 객제를 생성하는 행위를 가르켜 '인스턴스화' 라고 한다. 
    - 이렇게 생성이 된 객체를 '인스턴스' 라고 부른다. 
    - 클래스 & 객체 --> 메모리 관점에서 보면 매우 차이 있음 
        - 클래스에 존재하는 변수와 메소드는 메모리 공간에 할당된 형태로 존재하지 않음 --> 접근도 호출도 불가능한 상태 
        - 객체는 메모리 공간에 할당이 이루어짐 
    - 클래스를 정의하는 것은 자바에서 제공하는 기본 자료형 이외에 프로그래머가 새로운 이름의 자료형을 정의하는 것.
        
        - 예시)
            FruitSeller seller1 = new FruitSeller();
            instMethod(seller1);
            
            public void instMethod(FruitSeller seller2)
            {
                ....
            }
            --> 여기서 매개변수로 선언된 seller2에 seller1이 저장하고 잇는 객체의 참조값이 전달된다. 즉, 참조변수 seller1과 seller2가 하나의 객체를 동시에 참조하는 상황.
 
 - 하나의 객체가 다른 하나의 객체에게 메시지를 전달하는 방법은 메소드 호출을 기반으로 한다. 그래서 객체지향에서는 이러한 형태의 메소드 호출을 가리켜 '메시지 전달' 이라고 한다. 
 - 특정 개체로 초기화가 이뤄지지 않는다면 null로 초기화 할 수 있다. 

 ### 생성자 (Constructor)
 - 위에서 진행했던 과일장수 문제를 확장해서 과일장수가 2명 있다고 생각해보자 
 - 과일장수마다 사과의 가격이 다를 것이기 때문에 final APPLE_PRICE 로 정의한 부분이 문제가 된다. 
 - final로 사과가격을 지정하는 것이 아니라, 인스턴스를 생성하고 나서, 인스턴스 변수를 각각 초기화 하는 방식을 사용해야 한다. 
 
 - ch7의 Fruit2.java를 확인해보면 2가지 문제점이 있다는 것을 알수 있다. 
    1. 인스턴스를 생성하고 난 다음에 초기화하는 작업을 해야한다. 한번에 생성과 초기화가 되지 않고 두줄에 걸쳐 해야함
    2. 인스턴스 변수 APPLE_PRICE의 final 선언이 사라짐 (인스턴스 생성 이후 변경되지 않을 인스턴스 변수를 final로 선언함으로써 프로그램의 안전성을 향상시켰었음)
        초기화가 이루어지지 않은 final 변수는 한번의 초기화 기회를 가진다. 
        하지만 인스턴스 메소드는 두번 이상 호출될 수 있다. 
        그러므로 인스턴스 메소드 내에서 final 변수의 값을 초기화하는 행위가 허용되지 않는 것이다. 
        그러타면 딱한번만 호춛되는 메소드는? --> 생성자      
 
 - 생성자 
    - 생성자가 되기 위한 조건 
       1. 클래스의 이름과 동일한 이름의 메소드 
       2. 반환형이 선언되어 있지 않으면서, 반환하지 않는 메소드 
    - 생성자는 인스턴스 생성시 딱 한번 호출되는 메소드
    - Number num1 = new Number() --> new의 오른편에 있는 부분이 인스턴스의 생성과정에서 호출될 생성자를 명시하는 부분. 
        new Number --> Number의 인스턴스 생성 / Number() --> Number() 생성자 호출
    ---> "자바의 인스턴스 생성시에는 반드시 생성자가 호출되어야한다." 
    
    - 값을 전달받는 생성자 --> 이것이 있으므로 생성자를 이용해 인스턴스 변수의 초기화를 수월하게 할 수 있음을 깨닫게 됨 
    
 - Fruit2.java를 위에서 배운 값을 전달받는 생성자를 이용해 발전시켜보자 
 - 생성자가 없어도 인스턴스 생성이 가능한 이유 : 디폴트 생성자 (인자를 받지 않으면 하는 일이 아무것도없음)
 
 ### 자바의 이름 규칙 
 - 클래스의 이름 규칙
    - 'Camel Case'
        첫 문자는 대문자로 시작한다. 
        둘 이상의 단어가 묶여서 하나의 이름을 구성할 때, 새로 시작하는 단어는 대문자로 한다. 
        
 - 메소드와 변수의 이름 규칙 
    - 첫문자를 소문자로 시작하는 Camel Case방식을 사용한다. 
    
 - 상수의 이름 규칙 
    - 상수와 변수를 구분할 수 있도록 모든 문자를 대문자로 구성하는 것이 관례
    - 둘 이상의 단어가 연결되어야 하는 경우에는 _(언더바)를 사용한다. 
    
 # 자바 기본 공부 8 
 ## 클래스 패스와 패키지 
 
 ### 클래스 패스(class path)의 지정 
 - classpathtest 디렉토리 안에 java파일을 저장하고 컴파일 한후 
 - java파일의 일부인 class를 classpathtest의 서브클래스 mysubclass를 만들어 옮긴후 실행하면 문제가 발생한다. 
 - java.exe를 실행한 디렉토리에서만 가상머진에 올려질 클래스를 찾기 때문이다. 
 - 이때는 'java.exe를 실행시킨 현재 디렉토리의 서브 디렉토리인 mysubclass 디렉토리에서 클래스를 찾아보세요' 라는 메세지를 전달해야 한다. 
 - 위에서 말한 메세지는 '환경변수'라는 것을 이용해서 전달해야 한다. 
    - 환경변수 
        내가 만든 디렉토리인 classpathtest에 calc.exe가 존재 하지 않지만 classpathtest디렉토리에서 실행시켜 보면 실행이된다. --> 이것은 환경변수 path에 의해서 가능한 일이다. 
        환경변수 path에 저장된 정보가 무엇인지 확인해 보자 --> echo %path%로 확인가능 
        긴 문자열을 확인할 수 있다. 세미콜론에 의해서 데이터가 구분된다. 구분된 이 경로들은 모두 cmd에서 프로그램을 실행시킬 때, 해당 프로그램의 실행파일을 찾는 경로 정보로 활용됨
        환경변수라는 것은 path만 있는게 아님. 필요에 따라 추가할 수 있는 것이 환경변수. --> 자바에서는 클래스의 검색 경로를 지정할 수 있도록 classpath라는 환경변수를 정의하고 있다. 
        그래서 결론적으로 클래스의 경로정보를 classpath라는 환경변수에 추가함으로써 클래스의 검색경로를 확장할 수 있다. 
 - classpathtest 디렉토리에서 echo %classpath% 를 확인한다. 
 - set classpath=.; --> 이런식으로 classpath에 추가한다. 
 
 ### 패키지의 이해 
 - 기능만으로 클래스를 나누는 것은 제대로 된 클래스의 설계방식이 아니다. 
 - circle 문제를 이용해서 알아봄 
    - 한 팀은 둘레구하는 클래스 / 한 팀은 넓이 구하는 클래스 만들기로 함 
    - 만들어서 합치려고 보니 같은 class 이름을 사용함 
    - 우선, 컴파일부터 안되지만 디렉토리를 다르게 하여 컴파일한후 main에서 인스턴스를 생성할 때 제대로 생성되지 않을것이다. 
    
    --> 해결책 2가지 
        1. 컴파일 완료된 동일한 이름의 클래스 파일을 서로 다른 디렉토리에 저장한다. 
        2. 인스턴스 생성 시, 저장되어 있는 디렉토리 정보를 표시해서 클래스를 구분하게 한다. 
        
        orange.area.Circle. c1 = new orange.area.Circle();
        orange.perimeter.Circle. c1 = new orange.perimeter.Circle();
        --> orange : 패키지 (= 디렉토리) / area,perimeter : 서브패키지(= 서브디렉토리) 
        --> 패키지는 단순히 디렉토리를 나누는 개념이 아님. 패키지는 소스파일에 별도의 선언을 통해 만들어짐. 
        --> area 디렉토리에 존재하는 circle 클래스와 perimeter 디렉토리에 존재하는 circle 클래스를 각각 패키지 선언이라는 것을 통해 패키지의 개념으로 묶어주어야함 
        
 - 패키지와 클래스 패스의 관계
    - 
        