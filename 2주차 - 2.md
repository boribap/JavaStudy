# 2주차 - 2

## 메모리 사용 영역

    - JVM 실행 : OS가 JVM에게 필요한 메모리를 할당해준다
    - 위에서 할당받은 메모리의 구조
    - <Runtime Data Area>
        1. method area
            클래스 파일의 바이트코드가 로드되는 곳
            메인 메소드에서 사용하는 클래스 & static 변수 (= 프로그램 흐름을 구성하는 바이트 코드)
            JVM이 동작해서 클래스가 로딩될 때 생성되고, 모든 ㅅ레드가 공유하는 영역

        2. stack area
            원시타입의 데이터가 값과 함께 할당된다
            오브젝트 타입의 데이터들에 대한 참조를 위한 값들이 할당됨
            지역변수들은 scope에 따른 visibility를 가진다
            선입 후출
            각 스레드는 자신만의 stack을 가진다 (각 스레드에서 다른 스레드의 stack영역에 접근 불가)

        3. heap area
            데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역
            참조하는 변수나 필드가 없다면 의미없는 객체가 된다
                -> garbage collector의 대상이 됨
                    Mark & Sweep 과정
                    마크 - rechearble 한 것 마킹 (이 때 이것을 하기 위해 모든 스레드 중단됨 -> stop the world)
                    스윕 - 마킹안한거 지우기
            모든 스레드에서 공유한다 (스레드가 몇개이던 간에 합영역은 1개)
            주로 긴 생명주기 가지는 데이터들이 저장된
            모든 ObjectType은 heap영역에 생성됨
            heap영역에 있는 Object를 가리키는 참조변수가 stack에 올라감


        4. native method area
            자바외의 언어로 작성된 네이티브 코드를 위한 stack
        5. pc register
            현재 수행중인 JVM 명령 주소를 갖는다
            연산결과값을 메모리에 전달하기전 저장하는 cpu내의 기억장치
