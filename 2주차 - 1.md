# 2주차

- 연산자 (기본 연산 int 로 바꾼 후 수행)
    - 괄호 사용의 중요성 (우선순위와 연산 방향 때문에)
    - instanceof 연산자 ([https://arabiannight.tistory.com/entry/301](https://arabiannight.tistory.com/entry/301))
        - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용
        - instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.
    - 부호연산자
        - 산출타입은 int 타입이 된다는 것

                short s = 100;
                short result = -s; // 컴파일 에러 

    - ++x / x++ 의 구분
    - 비트반전 연산자(~)
        - 결과는 int
        - 최상위 비트도 반전됨
        - 부호반대인 수 구할때 사용됨 (비트반전  + 1)
    - NaN / Infinity
        - 0.0 or 0.0f 로 / 연산 → Infinity - Double.isInfinite(z)
        - % 연산 → NaN - Double.isNaN(z)
    - 비교연산자
        - 0.1 vs 0.1f
            - float 로 강제 형변환 or 정수 만들어야 같은 수 됨 (float의 0.1은 오차있기때문)
        - string

                String str1 = "bowon"; // 문자 리터럴로 String객체 생성 
                String str2 = "bowon"; // 위의 경우 같은 문자열이면 같은 객체 참조
                String str3 = new String("bowon");

            → str1 & str2 는 힙영역에서 같은 객체의 번지값을 가지고 있음 (문자열 리터럴이 동일하면 동일 String 객체를 참조하도록 되어있기 때문)

            → str3는 새로 객체를 생성한 것이므로 둘과는 다른 객체를 가르킴 

            → 그래서 문자열만을 비교할때에는 == 대신에 equals()를 사용해야 함 

    - 비트 이동 연산자
        - 오른쪽으로 비트를 이동시킬 시 빈칸은 MSB와 같은 값으로 채워진다 (>>)
        - >>> 를 사용하게 되면 위와 다르게 빈자리를 0으로 채운다
- 조건문과 반복문
    - switch
        - case 에서 break걸지 않으면 다음 case도 그냥 실행됨
    - continue
        - 이후 문장을 실행하지 않고 다음 반복으로 넘어간다
    - 향상된 for문

            for( 타입변수 : 배열){
            	실행문;
            }
            
            * 배열에서 가져올 첫번째 값이 존재하는지 평가 -> 있다면 해당 값을 변수에 저장 -> 실행문 실행
            * 배열에서 다음에 가져올 항목이 없으면 for문 종료
            * for문의 반복횟수 = 배열의 항목 수

- 참조타입
    - 변수는 stack영역에 / 객체는 heap영역에 생성됨
    - 객체의 번지를 참조하는 타입 : 배열, 열거, 클래스, 인터페이스
    - 메모리 사용 영역
        - 메소드 영역
        - 힙 영역
        - JVM 스택 영역
    - == : 참조하는 객체가 동일한가에 대해 (문자열 따지는것 아님)
    - null
        - 힙영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질수있다
        - null값도 초기값으로 사용할 수 있으므로 null로 초기화된 참조변수는 스택영역에 생성된다 (힙영역이 아닌)
    - new 연산자 : 객체 생성 연산자
    - 배열 타입
        - 배열도 참조변수이기때문에 null로 초기화 가능 → 배열 변수가 null값 가지는데 변수[인덱스]로 값을 읽거나 저장하게 되면 NullPointerException이 발생하게 된다
        - 배열의 길이 - 배열변수.length / 문자열의 길이 - 문자열변수.length()
        - 다차원 배열
            - new int[2][3] 인 배열을 만들면 힙영역에서는

                행에 해당하는 배열인 길이가 2인 배열 A객체 생성

                그리고 해당 행에 대한 열 배열 (길이 3인) B객체와 C 객체 생성 

                → 배열.length = 2 (행의 길이) / 배열[0].length = 3 / 배열[1].length = 3 (열의 길이)

                    for(int i=0; i<arr.length; i++){
                    	for(int j=0; j<arr[i].length; j++){
                    		//내용
                    	}
                    }

        - 참조타입 (클래스, 인스턴스) 배열 → 각 항목에 객체의 번지 지님

            → String은 클래스 타입이므로 String[] 배열은 각 항목에 문자열이 아닌 String 객체의 주소를 가지고 있음 

        - 얕은 복사 : 배열복사가 되면 복사되는 값이 객체의 번지이므로 새배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일
        - 깊은 복사 : 참조하는 객체도 별도로 생성

        ![](-85e3562d-f8eb-40b7-a3cb-eb5d383c362duntitled)

        ![](-cf76e205-bc21-4e7a-bede-fcfc54168a71untitled)

    - 열거 타입
        - 한정된 값만을 갖는 데이터 타입
        - 열거타입 이름으로 소스파일(.java)를 생성해야 함 / class 안에 enum 가능 / 클래스 외부에 enum 가능

                public enum 열거타입이름 {...}
                public enum Week {
                	MONDAY("월",M), 
                	TUESDAY, 
                	..
                } 
                
                * 열거타입이름 : 대문자로 시작
                * 열거 상수 : 대문자 / 여러단어라면 _사용 
                * 세미콜론 붙이지 않음 
                * 괄호를 사용하면 그것을 이용해서도 나타낼 수 있음 

        - 열거도 참조타입이기 때문에 각 열거 상수는 7개의 Week 객체로 생성됨
        - 메소드 영역(Week.class)에 생성된 열거 상수가 힙영역에 해당 Week객체를 참조하게 된다
        - 사용

            → 열거타입 열거타입변수 = 열거타입.열거상수 

            → 열거타입변수는 stack영역에 생성됨 

        - name() : 열거객체가 가지고 있는 문자열을 리턴한다
        - ordinal() : 열거 객체가 전체 열거 객체 중 몇번째 인지 리턴(0부터)
        - compareTo() : 매개값으로 주어진 열거 객체를 기준으로 전후로 몇 번째에 위치하는지를 비교한다 (전이면 -, 후면 +)
        - valueOf(String name) : 매개값으로 주어지는 문자열과 동일한 문자열을 가지는 열거객체를 리턴 / 외부로부터 문자열을 받아 열거 객체로 변환할때 유용
        - values() : 열거타입의 모든 열거 객체들을 배열로 만들어 리턴 / 배열의 인덱스는 열거객체의 순번과 같고 인덱스의 값은 해당 순번의 열거 객체 번지이다.

        ![](-52018a34-39e6-487a-9370-36c00ef9043cuntitled)

    - psvm(Strting[] args) 를 하는 이유
        - 커맨드 라인에서 파라미터를 넘기기 위해 문자열배열을 사용하는 것
        - args[0] 과 같은 것을 이용해서 파라미터로 넘어온 값(입력된값)을 활용할 수 있다.

- 정수화 → Integer.parseInt("문자열");
- 문자화 → Integer.toString(정수);
